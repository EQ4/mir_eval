<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mir_eval Documentation &mdash; mir_eval 0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="mir_eval 0.0 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">mir_eval 0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="mir-eval-documentation">
<h1><tt class="docutils literal"><span class="pre">mir_eval</span></tt> Documentation<a class="headerlink" href="#mir-eval-documentation" title="Permalink to this headline">¶</a></h1>
<p><tt class="docutils literal"><span class="pre">mir_eval</span></tt> is a Python library which provides a transparent, standaridized, and straightforward way to evaluate Music Information Retrieval systems.
It can be used in any of the following ways:</p>
<ul class="simple">
<li>By importing it and calling it from your Python code (see <a class="reference internal" href="#installation"><em>Installing mir_eval</em></a> and <a class="reference internal" href="#mir-eval-quickstart"><em>Quickstart: Using mir_eval in Python code</em></a>)</li>
<li>Via the included evaluator Python scripts (see <a class="reference internal" href="#installation"><em>Installing mir_eval</em></a> and <a class="reference internal" href="#evaluators"><em>Quickstart: Using the evaluators</em></a>)</li>
<li>Via the evaluator binaries, which can be run without any additional dependencies (skip straight to <a class="reference internal" href="#evaluators"><em>Quickstart: Using the evaluators</em></a>)</li>
</ul>
<p>If you use <tt class="docutils literal"><span class="pre">mir_eval</span></tt> in a research project, please cite the following paper:</p>
<ol class="upperalpha simple" start="3">
<li>Raffel, B. McFee, E. J. Humphrey, J. Salamon, O. Nieto, D. Liang, and D. P. W. Ellis, <a class="reference external" href="http://colinraffel.com/publications/ismir2014mir_eval.pdf">&#8220;mir_eval: A Transparent Implementation of Common MIR Metrics&#8221;</a>, Proceedings of the 15th International Conference on Music Information Retrieval, 2014.</li>
</ol>
<div class="section" id="quickstart-using-the-evaluators">
<span id="evaluators"></span><h2>Quickstart: Using the evaluators<a class="headerlink" href="#quickstart-using-the-evaluators" title="Permalink to this headline">¶</a></h2>
<p>The fastest way to get up and running with <tt class="docutils literal"><span class="pre">mir_eval</span></tt> is to use the evaluators.
These are scripts which can be run from the command line and utilize <tt class="docutils literal"><span class="pre">mir_eval</span></tt> to compute metrics according to reference and estimated annotations you provide.
To use the evaluators, you can either install <tt class="docutils literal"><span class="pre">mir_eval</span></tt> and its dependencies (see <a class="reference internal" href="#installation"><em>Installing mir_eval</em></a>) and run them as Python scripts, or you can download standalone binaries which are just precompiled executables of the evaluator scripts and have no dependencies (good for users who don&#8217;t use Python).
The evaluator Python scripts can be found in the <tt class="docutils literal"><span class="pre">mir_eval</span></tt> github repository in the <tt class="docutils literal"><span class="pre">evaluators</span></tt> folder:</p>
<p><a class="reference external" href="http://github.com/craffel/mir_eval/tree/master/evaluators">http://github.com/craffel/mir_eval/tree/master/evaluators</a></p>
<p>The standalone binaries can be downloaded here for Mac OS X (64-bit):</p>
<p><a class="reference external" href="http://labrosa.ee.columbia.edu/mir_eval/mir_eval_mac.tar.gz">http://labrosa.ee.columbia.edu/mir_eval/mir_eval_mac.tar.gz</a></p>
<p>or here for Windows:</p>
<p><a class="reference external" href="http://labrosa.ee.columbia.edu/mir_eval/mir_eval_win.tar.gz">http://labrosa.ee.columbia.edu/mir_eval/mir_eval_win.tar.gz</a></p>
<p>One evaluator is included for each of the MIR tasks implemented in <tt class="docutils literal"><span class="pre">mir_eval</span></tt>.
By way of example, we&#8217;ll cover the usage of the beat detection evaluator <tt class="docutils literal"><span class="pre">beat_eval</span></tt>.
To use an evaluator for a different task, simply replace <tt class="docutils literal"><span class="pre">beat_eval</span></tt> in the following with the name of the evaluator for the task you&#8217;re interested in.
To get usage help, simply run</p>
<p><tt class="docutils literal"><span class="pre">./beat_eval.py</span> <span class="pre">--help</span></tt></p>
<p>to use the Python script evaluator or</p>
<p><tt class="docutils literal"><span class="pre">./beat_eval</span> <span class="pre">--help</span></tt></p>
<p>in Mac OS X or</p>
<p><tt class="docutils literal"><span class="pre">beat_eval.exe</span> <span class="pre">--help</span></tt></p>
<p>in Windows.
For example, to evaluate generated beat times stored in the file <tt class="docutils literal"><span class="pre">estimated_beats.txt</span></tt> against ground-truth beats stored in the file <tt class="docutils literal"><span class="pre">reference_beats.txt</span></tt> and store the resulting scores in <tt class="docutils literal"><span class="pre">results.json</span></tt>, simply run</p>
<p><tt class="docutils literal"><span class="pre">./beat_eval.py</span> <span class="pre">-o</span> <span class="pre">results.json</span> <span class="pre">reference_beats.txt</span> <span class="pre">estimated_beats.txt</span></tt></p>
<p>to use the Python script evaluator or</p>
<p><tt class="docutils literal"><span class="pre">./beat_eval</span> <span class="pre">-o</span> <span class="pre">results.json</span> <span class="pre">reference_beats.txt</span> <span class="pre">estimated_beats.txt</span></tt></p>
<p>to use the binary in Mac OS X or</p>
<p><tt class="docutils literal"><span class="pre">beat_eval.exe</span> <span class="pre">-o</span> <span class="pre">results.json</span> <span class="pre">reference_beats.txt</span> <span class="pre">estimated_beats.txt</span></tt></p>
<p>to use the binary in Windows.
The file <tt class="docutils literal"><span class="pre">results.json</span></tt> will now contain the achieved scores in machine-parsable, human-readable json format.  Nice!</p>
</div>
<div class="section" id="quickstart-using-mir-eval-in-python-code">
<span id="mir-eval-quickstart"></span><h2>Quickstart: Using <tt class="docutils literal"><span class="pre">mir_eval</span></tt> in Python code<a class="headerlink" href="#quickstart-using-mir-eval-in-python-code" title="Permalink to this headline">¶</a></h2>
<p>Once you&#8217;ve installed <tt class="docutils literal"><span class="pre">mir_eval</span></tt> (see <a class="reference internal" href="#installation"><em>Installing mir_eval</em></a>), you can import it in your Python code as follows:</p>
<p><tt class="docutils literal"><span class="pre">import</span> <span class="pre">mir_eval</span></tt></p>
<p>From here, you will typically either load in data and call the <tt class="docutils literal"><span class="pre">evaluate()</span></tt> function from the appropriate submodule like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference_beats.txt&#39;</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated_beats.txt&#39;</span><span class="p">)</span>
<span class="c"># Scores will be a dict containing scores for all of the metrics</span>
<span class="c"># implemented in mir_eval.beat.  The keys are metric names</span>
<span class="c"># and values are the scores achieved</span>
<span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
<p>or you&#8217;ll load in the data, do some preprocessing, and call specific metric functions from the appropriate submodule like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference_beats.txt&#39;</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated_beats.txt&#39;</span><span class="p">)</span>
<span class="c"># Crop out beats before 5s, a common preprocessing step</span>
<span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="c"># Compute the F-measure metric and store it in f_measure</span>
<span class="n">f_measure</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
<p>The documentation for each metric function, found in the <a class="reference internal" href="#mir-eval"><em>mir_eval</em></a> section below, contains further usage information.</p>
</div>
<div class="section" id="installing-mir-eval">
<span id="installation"></span><h2>Installing <tt class="docutils literal"><span class="pre">mir_eval</span></tt><a class="headerlink" href="#installing-mir-eval" title="Permalink to this headline">¶</a></h2>
<p>The simplest way to instal <tt class="docutils literal"><span class="pre">mir_eval</span></tt> is by using <tt class="docutils literal"><span class="pre">pip</span></tt>, which will also install the required dependencies (Scipy and Numpy) if needed.
To install <tt class="docutils literal"><span class="pre">mir_eval</span></tt> using <tt class="docutils literal"><span class="pre">pip</span></tt>, simply run</p>
<p><tt class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">mir_eval</span></tt></p>
<p>Alternatively, you can install <tt class="docutils literal"><span class="pre">mir_eval</span></tt> from source by first installing Scipy/Numpy via <tt class="docutils literal"><span class="pre">pip</span></tt> or by following the instructions here:
<a class="reference external" href="http://www.scipy.org/install.html">http://www.scipy.org/install.html</a>
and then running</p>
<p><tt class="docutils literal"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></tt></p>
<p>from the source directory.</p>
</div>
<div class="section" id="mir-eval">
<span id="id1"></span><h2><tt class="docutils literal"><span class="pre">mir_eval</span></tt><a class="headerlink" href="#mir-eval" title="Permalink to this headline">¶</a></h2>
<p>The structure of the <tt class="docutils literal"><span class="pre">mir_eval</span></tt> Python module is as follows:
Each MIR task for which evaluation metrics are included in <tt class="docutils literal"><span class="pre">mir_eval</span></tt> is given its own submodule, and each metric is defined as a separate function in each submodule.
Every metric function includes detailed documentation, example usage, input validation, and references to the original paper which defined the metric (see the subsections below).
The task submodules also all contain a function <tt class="docutils literal"><span class="pre">evaluate()</span></tt>, which takes as input reference and estimated annotations and returns a dictionary of scores for all of the metrics implemented (for casual users, this is the place to start).
Finally, each task submodule also includes functions for common data pre-processing steps.</p>
<p><tt class="docutils literal"><span class="pre">mir_eval</span></tt> also includes the following additional submodules:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">io</span></tt> which contains convenience functions for loading in task-specific data from common file formats</li>
<li><tt class="docutils literal"><span class="pre">util</span></tt> which includes miscellaneous functionality shared across the submodules</li>
<li><tt class="docutils literal"><span class="pre">sonify</span></tt> which implements some simple methods for synthesizing annotations of various formats for &#8220;evaluation by ear&#8221;.</li>
</ul>
<p>The following subsections document each submodule.</p>
<div class="section" id="module-mir_eval.beat">
<span id="mir-eval-beat"></span><h3><a class="reference internal" href="#module-mir_eval.beat" title="mir_eval.beat"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.beat</span></tt></a><a class="headerlink" href="#module-mir_eval.beat" title="Permalink to this headline">¶</a></h3>
<p>The aim of a beat detection algorithm is to report the times at which a typical
human listener might tap their foot to a piece of music. As a result, most
metrics for evaluating the performance of beat tracking systems involve
computing the error between the estimated beat times and some reference list of
beat locations. Many metrics additionally compare the beat sequences at
different metric levels in order to deal with the ambiguity of tempo.</p>
<dl class="docutils">
<dt>Based on the methods described in:</dt>
<dd>Matthew E. P. Davies,  Norberto Degara, and Mark D. Plumbley.
&#8220;Evaluation Methods for Musical Audio Beat Tracking Algorithms&#8221;,
Queen Mary University of London Technical Report C4DM-TR-09-06
London, United Kingdom, 8 October 2009.</dd>
<dt>See also the Beat Evaluation Toolbox:</dt>
<dd><a class="reference external" href="https://code.soundsoftware.ac.uk/projects/beat-evaluation/">https://code.soundsoftware.ac.uk/projects/beat-evaluation/</a></dd>
</dl>
<div class="section" id="conventions">
<h4>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h4>
<p>Beat times should be provided in the form of a 1-dimensional array of beat
times in seconds in increasing order.  Typically, any beats which occur before
5s are ignored; this can be accomplished using
<a class="reference internal" href="#mir_eval.beat.trim_beats" title="mir_eval.beat.trim_beats"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.trim_beats()</span></tt></a>.</p>
</div>
<div class="section" id="metrics">
<h4>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.beat.f_measure" title="mir_eval.beat.f_measure"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.f_measure()</span></tt></a>: The F-measure of the beat sequence, where an
estimated beat is considered correct if it is sufficiently close to a
reference beat</li>
<li><a class="reference internal" href="#mir_eval.beat.cemgil" title="mir_eval.beat.cemgil"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.cemgil()</span></tt></a>: Cemgil&#8217;s score, which computes the sum of
Gaussian errors for each beat</li>
<li><a class="reference internal" href="#mir_eval.beat.goto" title="mir_eval.beat.goto"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.goto()</span></tt></a>: Goto&#8217;s score, a binary score which is 1 when at
least 25% of the estimated beat sequence closely matches the reference beat
sequence</li>
<li><a class="reference internal" href="#mir_eval.beat.p_score" title="mir_eval.beat.p_score"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.p_score()</span></tt></a>: McKinney&#8217;s P-score, which computes the
cross-correlation of the estimated and reference beat sequences represented
as impulse trains</li>
<li><a class="reference internal" href="#mir_eval.beat.continuity" title="mir_eval.beat.continuity"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.continuity()</span></tt></a>: Continuity-based scores which compute the
proportion of the beat sequence which is continuously correct</li>
<li><a class="reference internal" href="#mir_eval.beat.information_gain" title="mir_eval.beat.information_gain"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.beat.information_gain()</span></tt></a>: The Information Gain of a normalized
beat error histogram over a uniform distribution</li>
</ul>
<dl class="function">
<dt id="mir_eval.beat.trim_beats">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">trim_beats</tt><big>(</big><em>beats</em>, <em>min_beat_time=5.0</em><big>)</big><a class="headerlink" href="#mir_eval.beat.trim_beats" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes beats before min_beat_time.  A common preprocessing step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of beat times in seconds.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>min_beat_time <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum beat time to allow, default 5</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>beats_trimmed <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Trimmed beat array.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.validate">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">validate</tt><big>(</big><em>reference_beats</em>, <em>estimated_beats</em><big>)</big><a class="headerlink" href="#mir_eval.beat.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid beat time
arrays, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">estimated beat times, in seconds</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.f_measure">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">f_measure</tt><big>(</big><em>reference_beats</em>, <em>estimated_beats</em>, <em>f_measure_threshold=0.07</em><big>)</big><a class="headerlink" href="#mir_eval.beat.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F-measure of correct vs incorrectly predicted beats.
&#8220;Corectness&#8221; is determined over a small window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_measure</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                        estimated_beats)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">estimated beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>f_measure_threshold <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Window size, in seconds, default 0.07</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>f_score <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The computed F-measure score</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><p class="first last">Matthew E. P. Davies,  Norberto Degara, and
Mark D. Plumbley.  &#8220;Evaluation Methods for Musical Audio Beat
Tracking Algorithms&#8221;, Queen Mary University of London Technical
Report C4DM-TR-09-06 London, United Kingdom, 8 October 2009.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><p class="first last">S. Dixon, &#8220;Onset detection revisited,&#8221; in
Proceedings of 9th International Conference on Digital Audio
Effects (DAFx), Montreal, Canada, 2006, pp. 133-137.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.cemgil">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">cemgil</tt><big>(</big><em>reference_beats</em>, <em>estimated_beats</em>, <em>cemgil_sigma=0.04</em><big>)</big><a class="headerlink" href="#mir_eval.beat.cemgil" title="Permalink to this definition">¶</a></dt>
<dd><p>Cemgil&#8217;s score, computes a gaussian error of each estimated beat.
Compares against the original beat times and all metrical variations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cemgil_score</span><span class="p">,</span> <span class="n">cemgil_max</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">cemgil</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                    estimated_beats)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">query beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cemgil_sigma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Sigma parameter of gaussian error windows, default 0.04</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>cemgil_score <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Cemgil&#8217;s score for the original reference beats</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cemgil_max <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The best Cemgil score for all metrical variations</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><p class="first last">Matthew E. P. Davies,  Norberto Degara, and
Mark D. Plumbley.  &#8220;Evaluation Methods for Musical Audio Beat
Tracking Algorithms&#8221;, Queen Mary University of London Technical
Report C4DM-TR-09-06 London, United Kingdom, 8 October 2009.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><p class="first last">A. T. Cemgil, B. Kappen, P. Desain, and H. Honing,
&#8220;On tempo tracking: Tempogram representation and Kalman filtering,&#8221;
Journal Of New Music Research, vol. 28, no. 4, pp. 259-273, 2001.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.goto">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">goto</tt><big>(</big><em>reference_beats</em>, <em>estimated_beats</em>, <em>goto_threshold=0.35</em>, <em>goto_mu=0.2</em>, <em>goto_sigma=0.2</em><big>)</big><a class="headerlink" href="#mir_eval.beat.goto" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Goto&#8217;s score, a binary 1 or 0 depending on some specific
heuristic criteria</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">goto_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">query beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>goto_threshold <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Threshold of beat error for a beat to be &#8220;correct&#8221;, default 0.35</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>goto_mu <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The mean of the beat errors in the continuously correct
track must be less than this, default 0.2</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>goto_sigma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The std of the beat errors in the continuously correct track must
be less than this, default 0.2</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>goto_score <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Either 1.0 or 0.0 if some specific criteria are met</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><p class="first last">Matthew E. P. Davies,  Norberto Degara, and
Mark D. Plumbley.  &#8220;Evaluation Methods for Musical Audio Beat
Tracking Algorithms&#8221;, Queen Mary University of London Technical
Report C4DM-TR-09-06 London, United Kingdom, 8 October 2009.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><p class="first last">M. Goto and Y. Muraoka, &#8220;Issues in evaluating beat
tracking systems,&#8221; in Working Notes of the IJCAI-97 Workshop on
Issues in AI and Music - Evaluation and Assessment, 1997, pp. 9-16.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.p_score">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">p_score</tt><big>(</big><em>reference_beats</em>, <em>estimated_beats</em>, <em>p_score_threshold=0.2</em><big>)</big><a class="headerlink" href="#mir_eval.beat.p_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Get McKinney&#8217;s P-score.
Based on the autocorrelation of the reference and estimated beats</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">p_score</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">query beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>p_score_threshold <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Window size will be
p_score_threshold*median(inter_annotation_intervals),
default 0.2</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>correlation <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">McKinney&#8217;s P-score</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><p class="first last">Matthew E. P. Davies,  Norberto Degara, and
Mark D. Plumbley.  &#8220;Evaluation Methods for Musical Audio Beat
Tracking Algorithms&#8221;, Queen Mary University of London Technical
Report C4DM-TR-09-06 London, United Kingdom, 8 October 2009.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><p class="first last">M. F. McKinney, D. Moelants, M. E. P.
Davies, and A. Klapuri, &#8220;Evaluation of audio beat tracking and
music tempo extraction algorithms,&#8221; Journal of New Music Research,
vol. 36, no. 1, pp.  1-16, 2007.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.continuity">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">continuity</tt><big>(</big><em>reference_beats</em>, <em>estimated_beats</em>, <em>continuity_phase_threshold=0.175</em>, <em>continuity_period_threshold=0.175</em><big>)</big><a class="headerlink" href="#mir_eval.beat.continuity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get metrics based on how much of the estimated beat sequence is
continually correct.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CMLc</span><span class="p">,</span> <span class="n">CMLt</span><span class="p">,</span> <span class="n">AMLc</span><span class="p">,</span> <span class="n">AMLt</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">continuity</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                      estimated_beats)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">query beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>continuity_phase_threshold <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Allowable ratio of how far is the estimated beat
can be from the reference beat, default 0.175</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>continuity_period_threshold <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Allowable distance between the inter-beat-interval
and the inter-annotation-interval, default 0.175</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>CMLc <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Correct metric level, continuous accuracy</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>CMLt <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Correct metric level, total accuracy (continuity not required)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>AMLc <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Any metric level, continuous accuracy</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>AMLt <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Any metric level, total accuracy (continuity not required)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><p class="first last">Matthew E. P. Davies,  Norberto Degara, and
Mark D. Plumbley.  &#8220;Evaluation Methods for Musical Audio Beat
Tracking Algorithms&#8221;, Queen Mary University of London Technical
Report C4DM-TR-09-06 London, United Kingdom, 8 October 2009.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td><p class="first last">S. Hainsworth, &#8220;Techniques for the
automated analysis of musical audio,&#8221; Ph.D. dissertation,
Department of Engineering, Cambridge University, 2004.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><p class="first last">A. P. Klapuri, A. Eronen, and J. Astola,
&#8220;Analysis of the meter of acoustic musical signals,&#8221; IEEE
Transactions on Audio, Speech and Language Processing, vol. 14, no.
1, pp. 342-355, 2006.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.information_gain">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">information_gain</tt><big>(</big><em>reference_beats</em>, <em>estimated_beats</em>, <em>bins=41</em><big>)</big><a class="headerlink" href="#mir_eval.beat.information_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the information gain - K-L divergence of the beat error histogram
to a uniform histogram</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">trim_beats</span><span class="p">(</span><span class="n">estimated_beats</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">information_gain</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">information_gain</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span>
<span class="go">                                                      estimated_beats)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">query beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of bins in the beat error histogram, default 41</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>information_gain_score <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Entropy of beat error histogram</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[12]</td><td><p class="first last">Matthew E. P. Davies,  Norberto Degara, and
Mark D. Plumbley.  &#8220;Evaluation Methods for Musical Audio Beat
Tracking Algorithms&#8221;, Queen Mary University of London Technical
Report C4DM-TR-09-06 London, United Kingdom, 8 October 2009.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.beat.evaluate">
<tt class="descclassname">mir_eval.beat.</tt><tt class="descname">evaluate</tt><big>(</big><em>reference_beats</em>, <em>estimated_beats</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mir_eval.beat.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_beats</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">beat</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_beats</span><span class="p">,</span> <span class="n">estimated_beats</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_beats <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Query beat times, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs</dt>
<dd><p class="first last">Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.chord">
<span id="mir-eval-chord"></span><h3><a class="reference internal" href="#module-mir_eval.chord" title="mir_eval.chord"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.chord</span></tt></a><a class="headerlink" href="#module-mir_eval.chord" title="Permalink to this headline">¶</a></h3>
<p>Chord estimation algorithms produce a list of intervals and labels which denote
the chord being played over each timespan.  They are evaluated by comparing the
estimated chord labels to some reference, usually using a mapping to a chord
subalphabet (e.g. minor and major chords only, all triads, etc.).  There is no
single &#8216;right&#8217; way to compare two sequences of chord labels.  Embracing this
reality, every conventional comparison rule is provided.  Comparisons are made
over the different components of each chord (e.g. G:maj(6)/5): the root (G),
the root-invariant active semitones as determined by the quality
shorthand (maj) and scale degrees (6), and the bass interval (5).
This submodule provides functions both for comparing a sequences of chord
labels according to some chord subalphabet mapping and for using these
comparisons to score a sequence of estimated chords against a reference.</p>
<div class="section" id="id14">
<h4>Conventions<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>A sequence of chord labels is represented as a list of strings, where each
label is the chord name based on the syntax of <a class="footnote-reference" href="#harte2010towards" id="id15">[13]</a>.  Reference
and estimated chord label sequences should be of the same length for comparison
functions.  When converting the chord string into its constituent parts,</p>
<ul class="simple">
<li>Pitch class counting starts at C, e.g. C:0, D:2, E:4, F:5, etc.</li>
<li>Scale degree is represented as a string of the diatonic interval, relative to
the root note, e.g. &#8216;b6&#8217;, &#8216;#5&#8217;, or &#8216;7&#8217;</li>
<li>Bass intervals are represented as strings</li>
<li>Chord bitmaps are positional binary vectors indicating active pitch classes
and may be absolute or relative depending on context in the code.</li>
</ul>
<p>If no chord is present at a given point in time, it should have the label &#8216;N&#8217;,
which is defined in the variable <cite>mir_eval.chord.NO_CHORD</cite>.</p>
</div>
<div class="section" id="id16">
<h4>Metrics<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.chord.root" title="mir_eval.chord.root"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.root()</span></tt></a>: Only compares the root of the chords.</li>
<li><a class="reference internal" href="#mir_eval.chord.majmin" title="mir_eval.chord.majmin"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.majmin()</span></tt></a>: Only compares major, minor, and &#8220;no chord&#8221;
labels.</li>
<li><a class="reference internal" href="#mir_eval.chord.majmin_inv" title="mir_eval.chord.majmin_inv"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.majmin_inv()</span></tt></a>: Compares major/minor chords, with
inversions.  The bass note must exist in the triad.</li>
<li><a class="reference internal" href="#mir_eval.chord.mirex" title="mir_eval.chord.mirex"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.mirex()</span></tt></a>: A estimated chord is considered correct if it
shares <em>at least</em> three pitch classes in common.</li>
<li><a class="reference internal" href="#mir_eval.chord.thirds" title="mir_eval.chord.thirds"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.thirds()</span></tt></a>: Chords are compared at the level of major or
minor thirds (root and third), For example, both (&#8216;A:7&#8217;, &#8216;A:maj&#8217;) and
(&#8216;A:min&#8217;, &#8216;A:dim&#8217;) are equivalent, as the third is major and minor in
quality, respectively.</li>
<li><a class="reference internal" href="#mir_eval.chord.thirds_inv" title="mir_eval.chord.thirds_inv"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.thirds_inv()</span></tt></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.triads" title="mir_eval.chord.triads"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.triads()</span></tt></a>: Chords are considered at the level of triads
(major, minor, augmented, diminished, suspended), meaning that, in addition
to the root, the quality is only considered through #5th scale degree (for
augmented chords). For example, (&#8216;A:7&#8217;, &#8216;A:maj&#8217;) are equivalnet, while
(&#8216;A:min&#8217;, &#8216;A:dim&#8217;) and (&#8216;A:aug&#8217;, &#8216;A:maj&#8217;) are not.</li>
<li><a class="reference internal" href="#mir_eval.chord.triads_inv" title="mir_eval.chord.triads_inv"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.triads_inv()</span></tt></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.tetrads" title="mir_eval.chord.tetrads"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.tetrads()</span></tt></a>: Chords are considered at the level of the
entire quality in closed voicing, i.e. spanning only a single octave;
extended chords (9&#8217;s, 11&#8217;s and 13&#8217;s) are rolled into a single octave with any
upper voices included as extensions. For example, (&#8216;A:7&#8217;, &#8216;A:9&#8217;) are
equivlent but (&#8216;A:7&#8217;, &#8216;A:maj7&#8217;) are not.</li>
<li><a class="reference internal" href="#mir_eval.chord.tetrads_inv" title="mir_eval.chord.tetrads_inv"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.tetrads_inv()</span></tt></a>: Same as above, with inversions (bass
relationships).</li>
<li><a class="reference internal" href="#mir_eval.chord.sevenths" title="mir_eval.chord.sevenths"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.sevenths()</span></tt></a>: Compares according to MIREX &#8220;sevenths&#8221;
rules; that is, only major, major seventh, seventh, minor, minor seventh and
no chord labels are compared.</li>
<li><a class="reference internal" href="#mir_eval.chord.sevenths_inv" title="mir_eval.chord.sevenths_inv"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.chord.sevenths_inv()</span></tt></a>: Same as above, with inversions (bass
relationships).</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">references:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="harte2010towards" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[13]</a></td><td><p class="first last">C. Harte. Towards Automatic Extraction of Harmony
Information from Music Signals. PhD thesis, Queen Mary University of
London, August 2010.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<dl class="exception">
<dt id="mir_eval.chord.InvalidChordException">
<em class="property">exception </em><tt class="descclassname">mir_eval.chord.</tt><tt class="descname">InvalidChordException</tt><big>(</big><em>message=''</em>, <em>chord_label=None</em><big>)</big><a class="headerlink" href="#mir_eval.chord.InvalidChordException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>Exception class for suspect / invalid chord labels.</p>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.pitch_class_to_semitone">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">pitch_class_to_semitone</tt><big>(</big><em>pitch_class</em><big>)</big><a class="headerlink" href="#mir_eval.chord.pitch_class_to_semitone" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pitch class to semitone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>pitch_class <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Spelling of a given pitch class, e.g. &#8216;C#&#8217;, &#8216;Gbb&#8217;</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>semitone <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Semitone value of the pitch class.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>InvalidChordException</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.scale_degree_to_semitone">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">scale_degree_to_semitone</tt><big>(</big><em>scale_degree</em><big>)</big><a class="headerlink" href="#mir_eval.chord.scale_degree_to_semitone" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a scale degree to semitone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>scale degree <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Spelling of a relative scale degree, e.g. &#8216;b3&#8217;, &#8216;7&#8217;, &#8216;#5&#8217;</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>semitone <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Relative semitone of the scale degree, wrapped to a single octave</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>InvalidChordException</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.scale_degree_to_bitmap">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">scale_degree_to_bitmap</tt><big>(</big><em>scale_degree</em><big>)</big><a class="headerlink" href="#mir_eval.chord.scale_degree_to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bitmap representation of a scale degree.</p>
<p>Note that values in the bitmap may be negative, indicating that the
semitone is to be removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>scale_degree <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Spelling of a relative scale degree, e.g. &#8216;b3&#8217;, &#8216;7&#8217;, &#8216;#5&#8217;</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>bitmap <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, in [-1, 0, 1]</span></dt>
<dd><p class="first last">Bitmap representation of this scale degree (12-dim).</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.quality_to_bitmap">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">quality_to_bitmap</tt><big>(</big><em>quality</em><big>)</big><a class="headerlink" href="#mir_eval.chord.quality_to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bitmap for a given quality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>quality <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chord quality name.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>bitmap <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Bitmap representation of this quality (12-dim).</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>InvalidChordException</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.reduce_extended_quality">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">reduce_extended_quality</tt><big>(</big><em>quality</em><big>)</big><a class="headerlink" href="#mir_eval.chord.reduce_extended_quality" title="Permalink to this definition">¶</a></dt>
<dd><p>Map an extended chord quality to a simpler one, moving upper voices to
a set of scale degree extensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>quality <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Extended chord quality to reduce.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>base_quality <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">New chord quality.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>extensions <span class="classifier-delimiter">:</span> <span class="classifier">set</span></dt>
<dd><p class="first last">Scale degrees extensions for the quality.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.validate_chord_label">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">validate_chord_label</tt><big>(</big><em>chord_label</em><big>)</big><a class="headerlink" href="#mir_eval.chord.validate_chord_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for well-formedness of a chord label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>chord <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chord label to validate.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>InvalidFormatException</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.split">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">split</tt><big>(</big><em>chord_label</em>, <em>reduce_extended_chords=False</em><big>)</big><a class="headerlink" href="#mir_eval.chord.split" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Parse a chord label into its four constituent parts:</dt>
<dd><ul class="first last simple">
<li>root</li>
<li>quality shorthand</li>
<li>scale degrees</li>
<li>bass</li>
</ul>
</dd>
<dt>Note: Chords lacking quality AND interval information are major.</dt>
<dd><ul class="first last simple">
<li>If a quality is specified, it is returned.</li>
<li>If an interval is specified WITHOUT a quality, the quality field is
empty.</li>
</ul>
</dd>
</dl>
<p>Some examples:</p>
<div class="highlight-python"><div class="highlight"><pre>&#39;C&#39; -&gt; [&#39;C&#39;, &#39;maj&#39;, {}, &#39;1&#39;]
&#39;G#:min(*b3,*5)/5&#39; -&gt; [&#39;G#&#39;, &#39;min&#39;, {&#39;*b3&#39;, &#39;*5&#39;}, &#39;5&#39;]
&#39;A:(3)/6&#39; -&gt; [&#39;A&#39;, &#39;&#39;, {&#39;3&#39;}, &#39;6&#39;]
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>chord_label <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A chord label.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>chord_parts <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Split version of the chord label.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.join">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">join</tt><big>(</big><em>chord_root</em>, <em>quality=''</em>, <em>extensions=None</em>, <em>bass=''</em><big>)</big><a class="headerlink" href="#mir_eval.chord.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join the parts of a chord into a complete chord label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>chord_root <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Root pitch class of the chord, e.g. &#8216;C&#8217;, &#8216;Eb&#8217;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>quality <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Quality of the chord, e.g. &#8216;maj&#8217;, &#8216;hdim7&#8217;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>extensions <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Any added or absent scaled degrees for this chord, e.g. [&#8216;4&#8217;, &#8216;*3&#8217;]</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bass <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Scale degree of the bass note, e.g. &#8216;5&#8217;.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>chord_label <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A complete chord label.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>InvalidChordException</dt>
<dd><p class="first last">Thrown if the provided args yield a garbage chord label.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.encode">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">encode</tt><big>(</big><em>chord_label</em>, <em>reduce_extended_chords=False</em><big>)</big><a class="headerlink" href="#mir_eval.chord.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a chord label to numerical representations for evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>chord_label <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Chord label to encode.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>reduce_extended_chords <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Map the upper voicings of extended chords (9&#8217;s, 11&#8217;s, 13&#8217;s) to semitone
extensions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>root_number <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Absolute semitone of the chord&#8217;s root.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>semitone_bitmap <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, dtype=int</span></dt>
<dd><p class="first last">12-dim vector of relative semitones in the chord spelling.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bass_number <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Relative semitone of the chord&#8217;s bass note, e.g. 0=root, 7=fifth, etc.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>InvalidChordException</dt>
<dd><p class="first last">Thrown if the given bass note is not explicitly
named as an extension.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.encode_many">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">encode_many</tt><big>(</big><em>chord_labels</em>, <em>reduce_extended_chords=False</em><big>)</big><a class="headerlink" href="#mir_eval.chord.encode_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a set of chord labels to numerical representations for sane
evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>chord_labels <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Set of chord labels to encode.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>reduce_extended_chords <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Map the upper voicings of extended chords (9&#8217;s, 11&#8217;s, 13&#8217;s) to semitone
extensions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>root_number <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, dtype=int</span></dt>
<dd><p class="first last">Absolute semitone of the chord&#8217;s root.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>interval_bitmap <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, dtype=int</span></dt>
<dd><p class="first last">12-dim vector of relative semitones in the given chord quality.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bass_number <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, dtype=int</span></dt>
<dd><p class="first last">Relative semitones of the chord&#8217;s bass notes.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>InvalidChordException</dt>
<dd><p class="first last">Thrown if the given bass note is not explicitly
named as an extension.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.rotate_bitmap_to_root">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">rotate_bitmap_to_root</tt><big>(</big><em>bitmap</em>, <em>chord_root</em><big>)</big><a class="headerlink" href="#mir_eval.chord.rotate_bitmap_to_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift a relative bitmap to its asbolute pitch classes.</p>
<p>For clarity, the best explanation is an example. Given &#8216;G:Maj&#8217;, the root
and quality map are as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">root</span><span class="o">=</span><span class="mi">5</span>
<span class="n">quality</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c"># Relative chord shape</span>
</pre></div>
</div>
<p>After rotating to the root, the resulting bitmap becomes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">abs_quality</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c"># G, B, and D</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>bitmap <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(12,)</span></dt>
<dd><p class="first last">Bitmap of active notes, relative to the given root.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>chord_root <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Absolute pitch class number.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>bitmap <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(12,)</span></dt>
<dd><p class="first last">Absolute bitmap of active pitch classes.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.rotate_bitmaps_to_roots">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">rotate_bitmaps_to_roots</tt><big>(</big><em>bitmaps</em>, <em>roots</em><big>)</big><a class="headerlink" href="#mir_eval.chord.rotate_bitmaps_to_roots" title="Permalink to this definition">¶</a></dt>
<dd><p>Circularly shift a relative bitmaps to asbolute pitch classes.</p>
<p>See rotate_bitmap_to_root for more information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>bitmap <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(N, 12)</span></dt>
<dd><p class="first last">Bitmap of active notes, relative to the given root.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>root <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(N,)</span></dt>
<dd><p class="first last">Absolute pitch class number.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>bitmap <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(N, 12)</span></dt>
<dd><p class="first last">Absolute bitmaps of active pitch classes.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.rotate_bass_to_root">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">rotate_bass_to_root</tt><big>(</big><em>bass</em>, <em>chord_root</em><big>)</big><a class="headerlink" href="#mir_eval.chord.rotate_bass_to_root" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate a relative bass interval to its asbolute pitch class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>bass <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Relative bass interval.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>chord_root <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Absolute root pitch class.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>bass <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Pitch class of the bass intervalself.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.validate">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">validate</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a comparison function look like
valid chord labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.weighted_accuracy">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">weighted_accuracy</tt><big>(</big><em>comparisons</em>, <em>weights</em><big>)</big><a class="headerlink" href="#mir_eval.chord.weighted_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted accuracy of a list of chord comparisons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Here, we&#39;re using the &quot;thirds&quot; function to compare labels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># but any of the comparison functions would work.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>comparisons <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">List of chord comparison scores, in [0, 1] or -1</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Weights (not necessarily normalized) for each comparison.
This can be a list of interval durations</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>score <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Weighted accuracy</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.thirds">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">thirds</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.thirds" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along root &amp; third relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.thirds_inv">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">thirds_inv</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.thirds_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Score chords along root, third, &amp; bass relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">thirds_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.triads">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">triads</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.triads" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along triad (root &amp; quality to #5) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">triads</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.triads_inv">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">triads_inv</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.triads_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Score chords along triad (root, quality to #5, &amp; bass) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">triads_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.tetrads">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">tetrads</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.tetrads" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along tetrad (root &amp; full quality) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">tetrads</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.tetrads_inv">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">tetrads_inv</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.tetrads_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along seventh (root, quality) relationships.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">tetrads_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.root">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">root</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.root" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords according to roots.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.mirex">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">mirex</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.mirex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX rules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">mirex</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0]</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.majmin">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">majmin</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.majmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along major-minor rules. Chords with qualities outside
Major/minor/no-chord are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">majmin</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.majmin_inv">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">majmin_inv</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.majmin_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along major-minor rules, with inversions. Chords with
qualities outside Major/minor/no-chord are ignored, and the bass note must
exist in the triad (bass in [1, 3, 5]).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">majmin_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.sevenths">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">sevenths</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.sevenths" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX &#8216;sevenths&#8217; rules. Chords with qualities
outside [maj, maj7, 7, min, min7, N] are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">sevenths</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.sevenths_inv">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">sevenths_inv</tt><big>(</big><em>reference_labels</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.chord.sevenths_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare chords along MIREX &#8216;sevenths&#8217; rules. Chords with qualities
outside [maj, maj7, 7, min, min7, N] are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">est_labels</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">adjust_intervals</span><span class="p">(</span>
<span class="go">        est_intervals, est_labels, ref_intervals.min(),</span>
<span class="go">        ref_intervals.max(), mir_eval.chord.NO_CHORD,</span>
<span class="go">        mir_eval.chord.NO_CHORD)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span>
<span class="go">     ref_labels,</span>
<span class="go">     est_labels) = mir_eval.util.merge_labeled_intervals(</span>
<span class="go">         ref_intervals, ref_labels, est_intervals, est_labels)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">durations</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intervals_to_durations</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparisons</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">sevenths_inv</span><span class="p">(</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">est_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">weighted_accuracy</span><span class="p">(</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Reference chord labels to score against.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n</span></dt>
<dd><p class="first last">Estimated chord labels to score against.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>comparison_scores <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,), dtype=float</span></dt>
<dd><p class="first last">Comparison scores, in [0.0, 1.0], or -1 if the comparison is out of
gamut.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.chord.evaluate">
<tt class="descclassname">mir_eval.chord.</tt><tt class="descname">evaluate</tt><big>(</big><em>ref_intervals</em>, <em>ref_labels</em>, <em>est_intervals</em>, <em>est_labels</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mir_eval.chord.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes weighted accuracy for all comparison functions for the given
reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">chord</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="go">                                     est_intervals, est_labels)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">Reference chord intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">reference chord labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated chord intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(m,)</span></dt>
<dd><p class="first last">estimated chord labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs</dt>
<dd><p class="first last">Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.melody">
<span id="mir-eval-melody"></span><h3><a class="reference internal" href="#module-mir_eval.melody" title="mir_eval.melody"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.melody</span></tt></a><a class="headerlink" href="#module-mir_eval.melody" title="Permalink to this headline">¶</a></h3>
<p>Melody extraction algorithms aim to produce a sequence of frequency values
corresponding to the pitch of the dominant melody from a musical
recording.  For evaluation, an estimated pitch series is evaluated against a
reference based on whether the voicing (melody present or not) and the pitch
is correct (within some tolerance).</p>
<dl class="docutils">
<dt>For a detailed explanation of the measures please refer to:</dt>
<dd>J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, &#8220;Melody Extraction
from Polyphonic Music Signals: Approaches, Applications and Challenges&#8221;,
IEEE Signal Processing Magazine, 31(2):118-134, Mar. 2014.</dd>
</dl>
<div class="section" id="id17">
<h4>Conventions<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>Melody annotations are assumed to be given in the format of a 1d array of
frequency values which are accompanied by a 1d array of times denoting when
each frequency value occurs.  In a reference melody time series, a frequency
value of 0 denotes &#8220;unvoiced&#8221;.  In a estimated melody time series, unvoiced
frames can be indicated either by 0 Hz or by a negative Hz value - negative
values represent the algorithm&#8217;s pitch estimate for frames it has determined as
unvoiced, in case they are in fact voiced.</p>
<p>Metrics are computed using a sequence of reference and estimated pitches in
cents and boolean voicing arrays, both of which are sampled to the same
timebase.  The function <a class="reference internal" href="#mir_eval.melody.to_cent_voicing" title="mir_eval.melody.to_cent_voicing"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.to_cent_voicing()</span></tt></a> can be used to
convert a sequence of estimated and reference times and frequency values in Hz
to boolean voicing arrays and frequency arrays in the format required by the
metric functions.  By default, the convention is to resample the estimated
melody time series to the reference melody time series&#8217; timebase.</p>
</div>
<div class="section" id="id18">
<h4>Metrics<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.melody.voicing_measures" title="mir_eval.melody.voicing_measures"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.voicing_measures()</span></tt></a>: Voicing measures, including the
recall rate (proportion of frames labeled as melody frames in the reference
that are estimated as melody frames) and the false alarm
rate (proportion of frames labeled as non-melody in the reference that are
mistakenly estimated as melody frames)</li>
<li><a class="reference internal" href="#mir_eval.melody.raw_pitch_accuracy" title="mir_eval.melody.raw_pitch_accuracy"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.raw_pitch_accuracy()</span></tt></a>: Raw Pitch Accuracy, which
computes the proportion of melody frames in the reference for which the
frequency is considered correct (i.e. within half a semitone of the reference
frequency)</li>
<li><a class="reference internal" href="#mir_eval.melody.raw_chroma_accuracy" title="mir_eval.melody.raw_chroma_accuracy"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.raw_chroma_accuracy()</span></tt></a>: Raw Chroma Accuracy, where the
estimated and reference frequency sequences are mapped onto a single octave
before computing the raw pitch accuracy</li>
<li><a class="reference internal" href="#mir_eval.melody.overall_accuracy" title="mir_eval.melody.overall_accuracy"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.melody.overall_accuracy()</span></tt></a>: Overall Accuracy, which computes
the proportion of all frames correctly estimated by the algorithm, including
whether non-melody frames where labeled by the algorithm as non-melody</li>
</ul>
<dl class="function">
<dt id="mir_eval.melody.validate_voicing">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">validate_voicing</tt><big>(</big><em>ref_voicing</em>, <em>est_voicing</em><big>)</big><a class="headerlink" href="#mir_eval.melody.validate_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that voicing inputs to a metric are in the correct format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimated boolean voicing array</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.validate">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">validate</tt><big>(</big><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em><big>)</big><a class="headerlink" href="#mir_eval.melody.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that voicing and frequency arrays are well-formed.  To be used in
conjunction with validate_voicing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference pitch sequence in cents</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimated boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimate pitch sequence in cents</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.hz2cents">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">hz2cents</tt><big>(</big><em>freq_hz</em>, <em>base_frequency=10.0</em><big>)</big><a class="headerlink" href="#mir_eval.melody.hz2cents" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of frequency values in Hz to cents.
0 values are left in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>freq_hz <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of frequencies in Hz.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>base_frequency <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Base frequency for conversion.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of frequencies in cents, relative to base_frequency</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.freq_to_voicing">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">freq_to_voicing</tt><big>(</big><em>frequencies</em><big>)</big><a class="headerlink" href="#mir_eval.melody.freq_to_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from an array of frequency values to frequency array +
voice/unvoiced array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of frequencies.  A frequency &lt;= 0 indicates &#8220;unvoiced&#8221;.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of frequencies, all &gt;= 0.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>voiced <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Boolean array, same length as frequencies,
which indicates voiced or unvoiced</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.constant_hop_timebase">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">constant_hop_timebase</tt><big>(</big><em>hop</em>, <em>end_time</em><big>)</big><a class="headerlink" href="#mir_eval.melody.constant_hop_timebase" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a time series from 0 to end_time with times spaced hop apart</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>hop <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Spacing of samples in the time series</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>end_time <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Time series will span [0, end_time]</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Generated timebase</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.resample_melody_series">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">resample_melody_series</tt><big>(</big><em>times</em>, <em>frequencies</em>, <em>voicing</em>, <em>times_new</em>, <em>kind='linear'</em><big>)</big><a class="headerlink" href="#mir_eval.melody.resample_melody_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Resamples frequency and voicing time series to a new timescale.  Maintains
any zero (&#8220;unvoiced&#8221;) values in frequencies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Times of each frequency value</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of frequency values, &gt;= 0</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Boolean array which indicates voiced or unvoiced</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>times_new <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Times to resample frequency and voicing sequences to</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">kind parameter to pass to scipy.interpolate.interp1d.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>frequencies_resampled <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Frequency array resampled to new timebase</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>voicing_resampled <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, dtype=bool</span></dt>
<dd><p class="first last">Boolean voicing array resampled to new timebase</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.to_cent_voicing">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">to_cent_voicing</tt><big>(</big><em>ref_time</em>, <em>ref_freq</em>, <em>est_time</em>, <em>est_freq</em>, <em>base_frequency=10.0</em>, <em>hop=None</em>, <em>kind='linear'</em><big>)</big><a class="headerlink" href="#mir_eval.melody.to_cent_voicing" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts reference and estimated time/frequency (Hz) annotations to sampled
frequency (cent)/voicing arrays.</p>
<p>A zero frequency indicates &#8220;unvoiced&#8221;.</p>
<p>A negative frequency indicates &#8220;Predicted as unvoiced, but if it&#8217;s voiced,
this is the frequency estimate&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_time <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Time of each reference frequency value</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_freq <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of reference frequency values</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_time <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Time of each estimated frequency value</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_freq <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of estimated frequency values</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>base_frequency <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Base frequency in Hz for conversion to cents, default 10.0</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>hop <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Hop size, in seconds, to resample,
default None which means use ref_time</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kind <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">kind parameter to pass to scipy.interpolate.interp1d.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>ref_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, dtype=bool</span></dt>
<dd><p class="first last">Resampled reference boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Resampled reference frequency (cent) array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, dtype=bool</span></dt>
<dd><p class="first last">Resampled estimated boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Resampled estimated frequency (cent) array</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.voicing_measures">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">voicing_measures</tt><big>(</big><em>ref_voicing</em>, <em>est_voicing</em><big>)</big><a class="headerlink" href="#mir_eval.melody.voicing_measures" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the voicing recall and false alarm rates given two voicing
indicator sequences, one as reference (truth) and the other as the estimate
(prediction).  The sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="go">     est_v, est_c) = mir_eval.melody.to_cent_voicing(ref_time,</span>
<span class="go">                                                     ref_freq,</span>
<span class="go">                                                     est_time,</span>
<span class="go">                                                     est_freq)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">recall</span><span class="p">,</span> <span class="n">false_alarm</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">voicing_measures</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span>
<span class="go">                                                           est_v)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimated boolean voicing array</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>vx_recall <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Voicing recall rate, the fraction of voiced frames in ref
indicated as voiced in est</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>vx_false_alarm <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Voicing false alarm rate, the fraction of unvoiced frames in ref
indicated as voiced in est</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[14]</td><td><p class="first last">J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, &#8220;Melody
Extraction from Polyphonic Music Signals: Approaches, Applications
and Challenges&#8221;, IEEE Signal Processing Magazine, 31(2):118-134,
Mar. 2014.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[15]</td><td><p class="first last">G. E. Poliner, D. P. W. Ellis, A. F. Ehmann, E. Gomez, S.
Streich, and B. Ong. &#8220;Melody transcription from music audio:
Approaches and evaluation&#8221;, IEEE Transactions on Audio, Speech, and
Language Processing, 15(4):1247-1256, 2007.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.raw_pitch_accuracy">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">raw_pitch_accuracy</tt><big>(</big><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><big>)</big><a class="headerlink" href="#mir_eval.melody.raw_pitch_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw pitch accuracy given two pitch (frequency) sequences in
cents and matching voicing indicator sequences. The first pitch and voicing
arrays are treated as the reference (truth), and the second two as the
estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="go">     est_v, est_c) = mir_eval.melody.to_cent_voicing(ref_time,</span>
<span class="go">                                                     ref_freq,</span>
<span class="go">                                                     est_time,</span>
<span class="go">                                                     est_freq)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_pitch</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">raw_pitch_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="go">                                                   est_v, est_c)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference pitch sequence in cents</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimated boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimate pitch sequence in cents</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cent_tolerance <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum absolute deviation for a cent value to be considerd correct</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>raw_pitch <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Raw pitch accuracy, the fraction of voiced frames in ref_cent for
which est_cent provides a correct frequency values
(within cent_tolerance cents).</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[16]</td><td><p class="first last">J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, &#8220;Melody
Extraction from Polyphonic Music Signals: Approaches, Applications
and Challenges&#8221;, IEEE Signal Processing Magazine, 31(2):118-134,
Mar. 2014.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[17]</td><td><p class="first last">G. E. Poliner, D. P. W. Ellis, A. F. Ehmann, E. Gomez, S.
Streich, and B. Ong. &#8220;Melody transcription from music audio:
Approaches and evaluation&#8221;, IEEE Transactions on Audio, Speech, and
Language Processing, 15(4):1247-1256, 2007.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.raw_chroma_accuracy">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">raw_chroma_accuracy</tt><big>(</big><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><big>)</big><a class="headerlink" href="#mir_eval.melody.raw_chroma_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw chroma accuracy given two pitch (frequency) sequences
in cents and matching voicing indicator sequences. The first pitch and
voicing arrays are treated as the reference (truth), and the second two as
the estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="go">     est_v, est_c) = mir_eval.melody.to_cent_voicing(ref_time,</span>
<span class="go">                                                     ref_freq,</span>
<span class="go">                                                     est_time,</span>
<span class="go">                                                     est_freq)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_chroma</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">raw_chroma_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="go">                                                     est_v, est_c)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference pitch sequence in cents</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimated boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimate pitch sequence in cents</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cent_tolerance <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum absolute deviation for a cent value to be considerd correct</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>raw_chroma <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Raw chroma accuracy, the fraction of voiced frames in ref_cent for
which est_cent provides a correct frequency values (within
cent_tolerance cents), ignoring octave errors</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[18]</td><td><p class="first last">J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, &#8220;Melody
Extraction from Polyphonic Music Signals: Approaches, Applications
and Challenges&#8221;, IEEE Signal Processing Magazine, 31(2):118-134,
Mar. 2014.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[19]</td><td><p class="first last">G. E. Poliner, D. P. W. Ellis, A. F. Ehmann, E. Gomez, S.
Streich, and B. Ong. &#8220;Melody transcription from music audio:
Approaches and evaluation&#8221;, IEEE Transactions on Audio, Speech, and
Language Processing, 15(4):1247-1256, 2007.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.overall_accuracy">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">overall_accuracy</tt><big>(</big><em>ref_voicing</em>, <em>ref_cent</em>, <em>est_voicing</em>, <em>est_cent</em>, <em>cent_tolerance=50</em><big>)</big><a class="headerlink" href="#mir_eval.melody.overall_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the overall accuracy given two pitch (frequency) sequences in cents
and matching voicing indicator sequences. The first pitch and voicing
arrays are treated as the reference (truth), and the second two as the
estimate (prediction).  All 4 sequences must be of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="go">     est_v, est_c) = mir_eval.melody.to_cent_voicing(ref_time,</span>
<span class="go">                                                     ref_freq,</span>
<span class="go">                                                     est_time,</span>
<span class="go">                                                     est_freq)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">overall_accuracy</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">overall_accuracy</span><span class="p">(</span><span class="n">ref_v</span><span class="p">,</span> <span class="n">ref_c</span><span class="p">,</span>
<span class="go">                                                        est_v, est_c)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Reference pitch sequence in cents</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_voicing <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimated boolean voicing array</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_cent <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Estimate pitch sequence in cents</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>cent_tolerance <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum absolute deviation for a cent value to be considerd correct</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>overall_accuracy <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Overall accuracy, the total fraction of correctly estimates frames,
where provides a correct frequency values (within cent_tolerance
cents).</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[20]</td><td><p class="first last">J. Salamon, E. Gomez, D. P. W. Ellis and G. Richard, &#8220;Melody
Extraction from Polyphonic Music Signals: Approaches, Applications
and Challenges&#8221;, IEEE Signal Processing Magazine, 31(2):118-134,
Mar. 2014.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[21]</td><td><p class="first last">G. E. Poliner, D. P. W. Ellis, A. F. Ehmann, E. Gomez, S.
Streich, and B. Ong. &#8220;Melody transcription from music audio:
Approaches and evaluation&#8221;, IEEE Transactions on Audio, Speech, and
Language Processing, 15(4):1247-1256, 2007.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.melody.evaluate">
<tt class="descclassname">mir_eval.melody.</tt><tt class="descname">evaluate</tt><big>(</big><em>ref_time</em>, <em>ref_freq</em>, <em>est_time</em>, <em>est_freq</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mir_eval.melody.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate two melody (predominant f0) transcriptions, where the first is
treated as the reference (ground truth) and the second as the estimate to
be evaluated (prediction).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;ref.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_time</span><span class="p">,</span> <span class="n">est_freq</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_time_series</span><span class="p">(</span><span class="s">&#39;est.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">melody</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_time</span><span class="p">,</span> <span class="n">ref_freq</span><span class="p">,</span>
<span class="go">                                      est_time, est_freq)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_time <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Time of each reference frequency value</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_freq <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of reference frequency values</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_time <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Time of each estimated frequency value</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_freq <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of estimated frequency values</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs</dt>
<dd><p class="first last">Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.onset">
<span id="mir-eval-onset"></span><h3><a class="reference internal" href="#module-mir_eval.onset" title="mir_eval.onset"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.onset</span></tt></a><a class="headerlink" href="#module-mir_eval.onset" title="Permalink to this headline">¶</a></h3>
<p>The goal of an onset detection algorithm is to automatically determine when
notes are played in a piece of music.  The primary method used to evaluate
onset detectors is to first determine which estimated onsets are &#8220;correct&#8221;,
where correctness is defined as being within a small window of a reference
onset.</p>
<p>Based in part on this script:</p>
<blockquote>
<div><a class="reference external" href="https://github.com/CPJKU/onset_detection/blob/master/onset_evaluation.py">https://github.com/CPJKU/onset_detection/blob/master/onset_evaluation.py</a></div></blockquote>
<div class="section" id="id27">
<h4>Conventions<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>Onsets should be provided in the form of a 1-dimensional array of onset
times in seconds in increasing order.</p>
</div>
<div class="section" id="id28">
<h4>Metrics<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.onset.f_measure" title="mir_eval.onset.f_measure"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.onset.f_measure()</span></tt></a>: Precision, Recall, and F-measure scores
based on the number of esimated onsets which are sufficiently close to
reference onsets.</li>
</ul>
<dl class="function">
<dt id="mir_eval.onset.validate">
<tt class="descclassname">mir_eval.onset.</tt><tt class="descname">validate</tt><big>(</big><em>reference_onsets</em>, <em>estimated_onsets</em><big>)</big><a class="headerlink" href="#mir_eval.onset.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid onset time
arrays, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_onsets <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference onset locations, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_onsets <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">estimated onset locations, in seconds</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.onset.f_measure">
<tt class="descclassname">mir_eval.onset.</tt><tt class="descname">f_measure</tt><big>(</big><em>reference_onsets</em>, <em>estimated_onsets</em>, <em>window=0.05</em><big>)</big><a class="headerlink" href="#mir_eval.onset.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the F-measure of correct vs incorrectly predicted onsets.
&#8220;Corectness&#8221; is determined over a small window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">f_measure</span><span class="p">(</span><span class="n">reference_onsets</span><span class="p">,</span>
<span class="go">                                       estimated_onsets)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_onsets <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference onset locations, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_onsets <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">estimated onset locations, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Window size, in seconds</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>f_measure <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">2*precision*recall/(precision + recall)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">(# true positives)/(# true positives + # false positives)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">(# true positives)/(# true positives + # false negatives)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[22]</td><td><p class="first last">S. Dixon, &#8220;Onset detection revisited,&#8221; in
Proceedings of 9th International Conference on Digital Audio
Effects (DAFx), Montreal, Canada, 2006, pp. 133-137.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[23]</td><td><p class="first last">Sebastian Bock, Florian Krebs, and Markus Schedl. &#8220;Evaluating
the Online Capabilities of Onset Detection Methods&#8221;, in Proceedings
of the 13th International Society for Music Information Retrieval
Conference, 2012, pp. 49-54.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.onset.evaluate">
<tt class="descclassname">mir_eval.onset.</tt><tt class="descname">evaluate</tt><big>(</big><em>reference_onsets</em>, <em>estimated_onsets</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mir_eval.onset.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">reference_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;reference.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimated_onsets</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_events</span><span class="p">(</span><span class="s">&#39;estimated.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">onset</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_onsets</span><span class="p">,</span>
<span class="go">                                     estimated_onsets)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_onsets <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">reference onset locations, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_onsets <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">estimated onset locations, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs</dt>
<dd><p class="first last">Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.pattern">
<span id="mir-eval-pattern"></span><h3><a class="reference internal" href="#module-mir_eval.pattern" title="mir_eval.pattern"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.pattern</span></tt></a><a class="headerlink" href="#module-mir_eval.pattern" title="Permalink to this headline">¶</a></h3>
<p>Pattern discovery involves the identification of musical patterns (i.e. short
fragments or melodic ideas that repeat at least twice) both from audio and
symbolic representations.  The metrics used to evaluate pattern discovery
systems attempt to quantify the ability of the algorithm to not only determine
the present patterns in a piece, but also to find all of their occurrences.</p>
<dl class="docutils">
<dt>Based on the methods described here:</dt>
<dd>T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</dd>
</dl>
<div class="section" id="id31">
<h4>Conventions<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h4>
<p>The input format can be automatically generated by calling
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a>.  This format is a list of of a list of
tuples:</p>
<blockquote>
<div>Patterns: First level list
Occurrences: Second level list
Onset_Midi: Tuple of (onset_time, mid_note)</div></blockquote>
<p>A pattern is a list of occurrences. The first occurrence must be the prototype
of that pattern (i.e. the most representative of all the occurrences).  An
occurrence is a list of tuples containing the onset time and the midi note
number.</p>
</div>
<div class="section" id="id32">
<h4>Metrics<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.pattern.standard_FPR" title="mir_eval.pattern.standard_FPR"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.standard_FPR()</span></tt></a>: Strict metric in order to find the
possibly transposed patterns of exact length. This is the only metric that
considers transposed patterns.</li>
<li><a class="reference internal" href="#mir_eval.pattern.establishment_FPR" title="mir_eval.pattern.establishment_FPR"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.establishment_FPR()</span></tt></a>: Evaluates the amount of patterns
that were successfully identified by the estimated results, no matter how
many occurrences they found.  In other words, this metric captures how the
algorithm successfully _established_ that a pattern repeated at least twice,
and this pattern is also found in the reference annotation.</li>
<li><a class="reference internal" href="#mir_eval.pattern.occurrence_FPR" title="mir_eval.pattern.occurrence_FPR"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.occurrence_FPR()</span></tt></a>: Evaluation of how well an estimation
can effectively identify all the occurrences of the found patterns,
independently of how many patterns have been discovered. This metric has a
threshold parameter that indicates how similar two occurrences must be in
order to be considered equal.  In MIREX, this evaluation is run twice, with
thresholds .75 and .5.</li>
<li><a class="reference internal" href="#mir_eval.pattern.three_layer_FPR" title="mir_eval.pattern.three_layer_FPR"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.three_layer_FPR()</span></tt></a>: Aims to evaluate the general
similarity between the reference and the estimations, combining both the
establishment of patterns and the retrieval of its occurrences in a single F1
score.</li>
<li><a class="reference internal" href="#mir_eval.pattern.first_n_three_layer_P" title="mir_eval.pattern.first_n_three_layer_P"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.first_n_three_layer_P()</span></tt></a>: Computes the three-layer
precision for the first $N$ patterns only in order to measure the ability of
the algorithm to sort the identified patterns based on their relevance.</li>
<li><a class="reference internal" href="#mir_eval.pattern.first_n_target_proportion_R" title="mir_eval.pattern.first_n_target_proportion_R"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.pattern.first_n_target_proportion_R()</span></tt></a>: Computes the target
proportion recall for the first $N$ patterns only in order to measure the
ability of the algorithm to sort the identified patterns based on their
relevance.</li>
</ul>
<dl class="function">
<dt id="mir_eval.pattern.validate">
<tt class="descclassname">mir_eval.pattern.</tt><tt class="descname">validate</tt><big>(</big><em>reference_patterns</em>, <em>estimated_patterns</em><big>)</big><a class="headerlink" href="#mir_eval.pattern.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a metric look like valid pattern
lists, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The reference patterns using the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The estimated patterns in the same format</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.standard_FPR">
<tt class="descclassname">mir_eval.pattern.</tt><tt class="descname">standard_FPR</tt><big>(</big><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>tol=1e-05</em><big>)</big><a class="headerlink" href="#mir_eval.pattern.standard_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard F1 Score, Precision and Recall.</p>
<p>This metric checks if the prorotype patterns of the reference match
possible translated patterns in the prototype patterns of the estimations.
Since the sizes of these prototypes must be equal, this metric is quite
restictive and it tends to be 0 in most of 2013 MIREX results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">standard_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Params:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The reference patterns using the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The estimated patterns in the same format</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance level when comparing reference against estimation.
Default parameter is the one found in the original matlab code by
Tom Collins used for MIREX 2013.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>f_measure <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The standard F1 Score</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The standard Precision</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The standard Recall</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[24]</td><td><p class="first last">T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</p>
</td></tr>
</tbody>
</table>
<table class="last docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[25]</td><td><p class="first last">Tom Collins, Jeremy Thurlow, Robin Laney, Alistair Willis, and
Paul H.  Garthwaite. A comparative evaluation of algorithms for
discovering translational patterns in Baroque keyboard works. In
J.S. Downie and R. Veltkamp (Eds), Proc ISMIR, pp. 3-8, Utrecht,
2010.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.establishment_FPR">
<tt class="descclassname">mir_eval.pattern.</tt><tt class="descname">establishment_FPR</tt><big>(</big><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>similarity_metric='cardinality_score'</em><big>)</big><a class="headerlink" href="#mir_eval.pattern.establishment_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishment F1 Score, Precision and Recall.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">establishment_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="go">                                                 est_patterns)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Params:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The estimated patterns in the same format</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>similarity_metric <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">A string representing the metric to be used when computing the
similarity matrix. Accepted values:</p>
<blockquote class="last">
<div><ul>
<li><dl class="first docutils">
<dt>&#8220;cardinality_score&#8221;:</dt>
<dd><p class="first last">Count of the intersection between occurrences.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>f_measure <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The establishment F1 Score</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The establishment Precision</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The establishment Recall</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[26]</td><td><p class="first last">T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.occurrence_FPR">
<tt class="descclassname">mir_eval.pattern.</tt><tt class="descname">occurrence_FPR</tt><big>(</big><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>thres=0.75</em>, <em>similarity_metric='cardinality_score'</em><big>)</big><a class="headerlink" href="#mir_eval.pattern.occurrence_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Establishment F1 Score, Precision and Recall.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">occurrence_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="go">                                              est_patterns)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Params:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The estimated patterns in the same format</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>thres <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">How similar two occcurrences must be in order to be considered
equal</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>similarity_metric <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">A string representing the metric to be used
when computing the similarity matrix. Accepted values:</p>
<blockquote class="last">
<div><ul>
<li><dl class="first docutils">
<dt>&#8220;cardinality_score&#8221;:</dt>
<dd><p class="first last">Count of the intersection between occurrences.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>f_measure <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The establishment F1 Score</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The establishment Precision</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The establishment Recall</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[27]</td><td><p class="first last">T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.three_layer_FPR">
<tt class="descclassname">mir_eval.pattern.</tt><tt class="descname">three_layer_FPR</tt><big>(</big><em>reference_patterns</em>, <em>estimated_patterns</em><big>)</big><a class="headerlink" href="#mir_eval.pattern.three_layer_FPR" title="Permalink to this definition">¶</a></dt>
<dd><p>Three Layer F1 Score, Precision and Recall. As described by Meridith.</p>
<p>TODO: Add publication. Collins 2014?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">three_layer_FPR</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="go">                                               est_patterns)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Params:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The estimated patterns in the same format</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>f_measure <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The three-layer F1 Score</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The three-layer Precision</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The three-layer Recall</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[28]</td><td><p class="first last">T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.first_n_three_layer_P">
<tt class="descclassname">mir_eval.pattern.</tt><tt class="descname">first_n_three_layer_P</tt><big>(</big><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>n=5</em><big>)</big><a class="headerlink" href="#mir_eval.pattern.first_n_three_layer_P" title="Permalink to this definition">¶</a></dt>
<dd><p>First n three-layer precision.</p>
<p>This metric is basically the same as the three-layer FPR but it is only
applied to the first n estimated patterns, and it only returns the
precision. In MIREX and typically, n = 5.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">first_n_three_layer_P</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span>
<span class="go">                                               est_patterns, n=5)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Params:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The estimated patterns in the same format</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of patterns to consider from the estimated results, in
the order they appear in the matrix</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The first n three-layer Precision</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[29]</td><td><p class="first last">T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.first_n_target_proportion_R">
<tt class="descclassname">mir_eval.pattern.</tt><tt class="descname">first_n_target_proportion_R</tt><big>(</big><em>reference_patterns</em>, <em>estimated_patterns</em>, <em>n=5</em><big>)</big><a class="headerlink" href="#mir_eval.pattern.first_n_target_proportion_R" title="Permalink to this definition">¶</a></dt>
<dd><p>Firt n target proportion establishment recall metric.</p>
<p>This metric is similar is similar to the establishment FPR score, but it
only takes into account the first n estimated patterns and it only
outputs the Recall value of it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">first_n_target_proportion_R</span><span class="p">(</span>
<span class="go">                                    ref_patterns, est_patterns, n=5)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Params:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The estimated patterns in the same format</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of patterns to consider from the estimated results, in
the order they appear in the matrix.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The first n target proportion Recall.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[30]</td><td><p class="first last">T. Collins. MIREX task: Discovery of repeated themes &amp; sections.
<a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_&amp;_Sections</a>,
2013.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.pattern.evaluate">
<tt class="descclassname">mir_eval.pattern.</tt><tt class="descname">evaluate</tt><big>(</big><em>ref_patterns</em>, <em>est_patterns</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mir_eval.pattern.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Load data and perform the evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;ref_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_patterns</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_patterns</span><span class="p">(</span><span class="s">&quot;est_pattern.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_patterns</span><span class="p">,</span> <span class="n">est_patterns</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Params:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The reference patterns in the format returned by
<a class="reference internal" href="#mir_eval.io.load_patterns" title="mir_eval.io.load_patterns"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_patterns()</span></tt></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_patterns <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The estimated patterns in the same format</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs</dt>
<dd><p class="first last">Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.segment">
<span id="mir-eval-segment"></span><h3><a class="reference internal" href="#module-mir_eval.segment" title="mir_eval.segment"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.segment</span></tt></a><a class="headerlink" href="#module-mir_eval.segment" title="Permalink to this headline">¶</a></h3>
<p>Evaluation criteria for structural segmentation fall into two categories:
boundary annotation and structural annotation.  Boundary annotation is the task
of predicting the times at which structural changes occur, such as when a verse
transitions to a refrain.  Metrics for boundary annotation compare estimated
segment boundaries to reference boundaries.  Structural annotation is the task
of assigning labels to detected segments.  The estimated labels may be
arbitrary strings - such as A, B, C, - and they need not describe functional
concepts.  Metrics for structural annotation are similar to those use for
clustering data.</p>
<div class="section" id="id40">
<h4>Conventions<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<p>Both boundary and structural annotation metrics require two dimensional arrays
with two columns, one for boundary start times and one for boundary end times.
Structural annotation further require lists of reference and estimated segment
labels which must have a length which is equal to the number of rows in the
corresponding list of boundary edges.  In both tasks, we assume that
annotations express a partitioning of the track into intervals.  The function
<a class="reference internal" href="#mir_eval.util.adjust_intervals" title="mir_eval.util.adjust_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.util.adjust_intervals()</span></tt></a> can be used to pad or crop the segment
boundaries to span the duration of the entire track.</p>
</div>
<div class="section" id="id41">
<h4>Metrics<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.segment.detection" title="mir_eval.segment.detection"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.detection()</span></tt></a>: An estimated boundary is considered
correct if it falls within a window around a reference boundary</li>
<li><a class="reference internal" href="#mir_eval.segment.deviation" title="mir_eval.segment.deviation"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.deviation()</span></tt></a>: Computes the median absolute time
difference from a reference boundary to its nearest estimated boundary, and
vice versa</li>
<li><a class="reference internal" href="#mir_eval.segment.pairwise" title="mir_eval.segment.pairwise"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.pairwise()</span></tt></a>: For classifying pairs of sampled time
instants as belonging to the same structural component</li>
<li><a class="reference internal" href="#mir_eval.segment.rand_index" title="mir_eval.segment.rand_index"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.rand_index()</span></tt></a>: Clusters reference and estimated
annotations and compares them by the Rand Index</li>
<li><a class="reference internal" href="#mir_eval.segment.ari" title="mir_eval.segment.ari"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.ari()</span></tt></a>: Computes the Rand index, adjusted for chance</li>
<li><a class="reference internal" href="#mir_eval.segment.nce" title="mir_eval.segment.nce"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.nce()</span></tt></a>: Interprets sampled reference and estimated
labels as samples of random variables $Y_R, Y_E$ from which the conditional
entropy of $Y_R$ given $Y_E$ (Under-Segmentation) and $Y_E$ given $Y_R$
(Over-Segmentation) are estimated</li>
<li><a class="reference internal" href="#mir_eval.segment.mutual_information" title="mir_eval.segment.mutual_information"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.segment.mutual_information()</span></tt></a>: Computes the standard,
normalized, and adjusted mutual information of sampled reference and
estimated segments</li>
</ul>
<dl class="function">
<dt id="mir_eval.segment.validate_boundary">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">validate_boundary</tt><big>(</big><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>trim</em><big>)</big><a class="headerlink" href="#mir_eval.segment.validate_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a segment boundary estimation
metric (i.e. one that only takes in segment intervals) look like valid
segment times, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">will the start and end events be trimmed?</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.validate_structure">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">validate_structure</tt><big>(</big><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em><big>)</big><a class="headerlink" href="#mir_eval.segment.validate_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input annotations to a structure estimation metric (i.e.
one that takes in both segment boundaries and their labels) look like valid
segment times and labels, and throws helpful errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(m,)</span></dt>
<dd><p class="first last">estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.detection">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">detection</tt><big>(</big><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>window=0.5</em>, <em>beta=1.0</em>, <em>trim=False</em><big>)</big><a class="headerlink" href="#mir_eval.segment.detection" title="Permalink to this definition">¶</a></dt>
<dd><p>Boundary detection hit-rate.</p>
<p>A hit is counted whenever an reference boundary is within <tt class="docutils literal"><span class="pre">window</span></tt> of a
estimated boundary.  Note that each boundary is matched at most once: this
is achieved by computing the size of a maximal matching between reference
and estimated boundary points, subject to the window constraint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># With 0.5s windowing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P05</span><span class="p">,</span> <span class="n">R05</span><span class="p">,</span> <span class="n">F05</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">                                                est_intervals,</span>
<span class="go">                                                window=0.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># With 3s windowing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P3</span><span class="p">,</span> <span class="n">R3</span><span class="p">,</span> <span class="n">F3</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">                                             est_intervals,</span>
<span class="go">                                             window=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Ignoring hits for the beginning and end of track</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">detection</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">                                          est_intervals,</span>
<span class="go">                                          window=0.5,</span>
<span class="go">                                          trim=True)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">size of the window of &#8216;correctness&#8217; around ground-truth beats
(in seconds)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">weighting constant for F-measure.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">if <tt class="docutils literal"><span class="pre">True</span></tt>, the first and last boundary times are ignored.
Typically, these denote start (0) and end-markers.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">precision of estimated predictions</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">recall of reference reference boundaries</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>f_measure <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">F-measure (weighted harmonic mean of <tt class="docutils literal"><span class="pre">precision</span></tt> and <tt class="docutils literal"><span class="pre">recall</span></tt>)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[31]</td><td><p class="first last">D. Turnbull, G. Lanckriet, E. Pampalk, and M. Goto. A supervised
approach for detecting boundaries in music using difference
features and boosting. In Proceedings of the 8th International
Society for Music Information Retrieval Conference (ISMIR), pages
51-54, 2007.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.deviation">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">deviation</tt><big>(</big><em>reference_intervals</em>, <em>estimated_intervals</em>, <em>trim=False</em><big>)</big><a class="headerlink" href="#mir_eval.segment.deviation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median deviations between reference
and estimated boundary times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s">&#39;ref.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est_intervals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">load_labeled_intervals</span><span class="p">(</span><span class="s">&#39;est.lab&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r_to_e</span><span class="p">,</span> <span class="n">e_to_r</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">deviation</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">                                                 est_intervals)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt></a> or
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>trim <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">if <tt class="docutils literal"><span class="pre">True</span></tt>, the first and last intervals are ignored.
Typically, these denote start (0.0) and end-of-track markers.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>reference_to_estimated <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">median time from each reference boundary to the
closest estimated boundary</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_to_reference <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">median time from each estimated boundary to the
closest reference boundary</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id43" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[32]</td><td><p class="first last">D. Turnbull, G. Lanckriet, E. Pampalk, and M. Goto. A supervised
approach for detecting boundaries in music using difference
features and boosting. In Proceedings of the 8th International
Society for Music Information Retrieval Conference (ISMIR), pages
51-54, 2007.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.pairwise">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">pairwise</tt><big>(</big><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><big>)</big><a class="headerlink" href="#mir_eval.segment.pairwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation evaluation by pair-wise agreement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.util.adjust_intervals(ref_intervals,</span>
<span class="go">                                                  ref_labels,</span>
<span class="go">                                                  t_min=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.util.adjust_intervals(est_intervals,</span>
<span class="go">                                                  est_labels,</span>
<span class="go">                                                  t_min=0,</span>
<span class="go">                                                  t_max=ref_intervals.max())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">precision</span><span class="p">,</span> <span class="n">recall</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">pairwise</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">                                                       ref_labels,</span>
<span class="go">                                                       est_intervals,</span>
<span class="go">                                                       est_labels)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(m,)</span></dt>
<dd><p class="first last">estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frame_size <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">length (in seconds) of frames for clustering</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">beta value for F-measure</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Precision of detecting whether frames belong in the same cluster</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Recall of detecting whether frames belong in the same cluster</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">F-measure of detecting whether frames belong in the same cluster</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id44" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[33]</td><td><p class="first last">M. Levy and M. Sandler. Structural segmentation of musical audio
by constrained clustering. IEEE Transactions on Audio, Speech, and
Language Processing, 16(2):318-326, 2008.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.rand_index">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">rand_index</tt><big>(</big><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><big>)</big><a class="headerlink" href="#mir_eval.segment.rand_index" title="Permalink to this definition">¶</a></dt>
<dd><p>(Non-adjusted) Rand index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.util.adjust_intervals(ref_intervals,</span>
<span class="go">                                                  ref_labels,</span>
<span class="go">                                                  t_min=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.util.adjust_intervals(est_intervals,</span>
<span class="go">                                                  est_labels,</span>
<span class="go">                                                  t_min=0,</span>
<span class="go">                                                  t_max=ref_intervals.max())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rand_index</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">rand_index</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">                                               ref_labels,</span>
<span class="go">                                               est_intervals,</span>
<span class="go">                                               est_labels)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(m,)</span></dt>
<dd><p class="first last">estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frame_size <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">length (in seconds) of frames for clustering</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">beta value for F-measure</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>rand_index <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Rand index</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id45" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[34]</td><td><p class="first last">W. M. Rand. Objective criteria for the evaluation of clustering
methods. Journal of the American Statistical association,
66(336):846-850, 1971.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.ari">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">ari</tt><big>(</big><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em><big>)</big><a class="headerlink" href="#mir_eval.segment.ari" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusted Rand Index (ARI) for frame clustering segmentation evaluation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.util.adjust_intervals(ref_intervals,</span>
<span class="go">                                                  ref_labels,</span>
<span class="go">                                                  t_min=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.util.adjust_intervals(est_intervals,</span>
<span class="go">                                                  est_labels,</span>
<span class="go">                                                  t_min=0,</span>
<span class="go">                                                  t_max=ref_intervals.max())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ari_score</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">ari</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="go">                                       est_intervals, est_labels)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(m,)</span></dt>
<dd><p class="first last">estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frame_size <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">length (in seconds) of frames for clustering</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>ari_score <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Adjusted Rand index between segmentations.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id46" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[35]</td><td><p class="first last">W. M. Rand. Objective criteria for the evaluation of clustering
methods. Journal of the American Statistical association,
66(336):846-850, 1971.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is assumed that <tt class="docutils literal"><span class="pre">intervals[-1]</span></tt> == length of song</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Segment intervals will be rounded down to the nearest multiple
of frame_size.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.mutual_information">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">mutual_information</tt><big>(</big><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em><big>)</big><a class="headerlink" href="#mir_eval.segment.mutual_information" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: mutual information metrics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.util.adjust_intervals(ref_intervals,</span>
<span class="go">                                                  ref_labels,</span>
<span class="go">                                                  t_min=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.util.adjust_intervals(est_intervals,</span>
<span class="go">                                                  est_labels,</span>
<span class="go">                                                  t_min=0,</span>
<span class="go">                                                  t_max=ref_intervals.max())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mi</span><span class="p">,</span> <span class="n">ami</span><span class="p">,</span> <span class="n">nmi</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">                                                         ref_labels,</span>
<span class="go">                                                         est_intervals,</span>
<span class="go">                                                         est_labels)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(m,)</span></dt>
<dd><p class="first last">estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frame_size <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">length (in seconds) of frames for clustering</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>MI <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Mutual information between segmentations</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>AMI <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Adjusted mutual information between segmentations.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NMI <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Normalize mutual information between segmentations</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is assumed that <cite>intervals[-1] == length of song</cite></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Segment intervals will be rounded down to the nearest multiple
of frame_size.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.nce">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">nce</tt><big>(</big><em>reference_intervals</em>, <em>reference_labels</em>, <em>estimated_intervals</em>, <em>estimated_labels</em>, <em>frame_size=0.1</em>, <em>beta=1.0</em><big>)</big><a class="headerlink" href="#mir_eval.segment.nce" title="Permalink to this definition">¶</a></dt>
<dd><p>Frame-clustering segmentation: normalized conditional entropy</p>
<p>Computes cross-entropy of cluster assignment, normalized by the
max-entropy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Trim or pad the estimate to match reference timing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.util.adjust_intervals(ref_intervals,</span>
<span class="go">                                                  ref_labels,</span>
<span class="go">                                                  t_min=0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.util.adjust_intervals(est_intervals,</span>
<span class="go">                                                  est_labels,</span>
<span class="go">                                                  t_min=0,</span>
<span class="go">                                                  t_max=ref_intervals.max())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S_over</span><span class="p">,</span> <span class="n">S_under</span><span class="p">,</span> <span class="n">S_F</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">nce</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">                                                  ref_labels,</span>
<span class="go">                                                  est_intervals,</span>
<span class="go">                                                  est_labels)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>reference_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(m,)</span></dt>
<dd><p class="first last">estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frame_size <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">length (in seconds) of frames for clustering</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">beta for F-measure</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>S_over</dt>
<dd><p class="first last">Over-clustering score:
<tt class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_est</span> <span class="pre">|</span> <span class="pre">y_ref)</span> <span class="pre">/</span> <span class="pre">log(|y_est|)</span></tt>
If <cite>|y_est|==1</cite>, then <cite>S_over</cite> will be 0.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S_under</dt>
<dd><p class="first last">Under-clustering score:
<tt class="docutils literal"><span class="pre">1</span> <span class="pre">-</span> <span class="pre">H(y_ref</span> <span class="pre">|</span> <span class="pre">y_est)</span> <span class="pre">/</span> <span class="pre">log(|y_ref|)</span></tt>
If <cite>|y_ref|==1</cite>, then <cite>S_under</cite> will be 0.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>S_F</dt>
<dd><p class="first last">F-measure for (S_over, S_under)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="id47" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[36]</td><td><p class="first last">Hanna M. Lukashevich. &#8220;Towards Quantitative Measures of
Evaluating Song Segmentation,&#8221; in Proceedings of the 9th
International Society for Music Information Retrieval Conference,
2007, pp. 375-380.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.segment.evaluate">
<tt class="descclassname">mir_eval.segment.</tt><tt class="descname">evaluate</tt><big>(</big><em>ref_intervals</em>, <em>ref_labels</em>, <em>est_intervals</em>, <em>est_labels</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mir_eval.segment.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span>
<span class="go">     ref_labels) = mir_eval.io.load_labeled_intervals(&#39;ref.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">est_intervals</span><span class="p">,</span>
<span class="go">     est_labels) = mir_eval.io.load_labeled_intervals(&#39;est.lab&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">segment</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">ref_intervals</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span>
<span class="go">                                       est_intervals, est_labels)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">reference segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ref_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">reference segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m, 2)</span></dt>
<dd><p class="first last">estimated segment intervals, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est_labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(m,)</span></dt>
<dd><p class="first last">estimated segment labels, in the format returned by
<a class="reference internal" href="#mir_eval.io.load_labeled_intervals" title="mir_eval.io.load_labeled_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled_intervals()</span></tt></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs</dt>
<dd><p class="first last">Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided annotations are not valid.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.separation">
<span id="mir-eval-separation"></span><h3><a class="reference internal" href="#module-mir_eval.separation" title="mir_eval.separation"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.separation</span></tt></a><a class="headerlink" href="#module-mir_eval.separation" title="Permalink to this headline">¶</a></h3>
<p>Source separation algorithms attempt to extract recordings of individual
sources from a recording of a mixture of sources.  Evaluation methods for
source separation compare the extracted sources from reference sources and
attempt to measure the perceptual quality of the separation.</p>
<dl class="docutils">
<dt>Currently, only bss_eval is implemented, as described in:</dt>
<dd>Emmanuel Vincent, Rémi Gribonval, and Cédric Févotte, &#8220;Performance
measurement in blind audio source separation,&#8221; IEEE Trans. on Audio,
Speech and Language Processing, 14(4):1462-1469, 2006.</dd>
<dt>See also the bss_eval MATLAB toolbox:</dt>
<dd><a class="reference external" href="http://bass-db.gforge.inria.fr/bss_eval/">http://bass-db.gforge.inria.fr/bss_eval/</a></dd>
</dl>
<div class="section" id="id48">
<h4>Conventions<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h4>
<p>An audio signal is expected to be in the format of a 1-dimensional array where
the entries are the samples of the audio signal.  When providing a group of
estimated or reference sources, they should be provided in a 2-dimensional
array, where the first dimension corresponds to the source number and the
second corresponds to the samples.</p>
</div>
<div class="section" id="id49">
<h4>Metrics<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><a class="reference internal" href="#mir_eval.separation.bss_eval_sources" title="mir_eval.separation.bss_eval_sources"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.separation.bss_eval_sources()</span></tt></a>: Computes the bss_eval metrics,
which optimally match the estimated sources to the reference sources and
measure the distortion and artifacts present in the estimated sources as well
as the interference between them.</li>
</ul>
<dl class="function">
<dt id="mir_eval.separation.validate">
<tt class="descclassname">mir_eval.separation.</tt><tt class="descname">validate</tt><big>(</big><em>reference_sources</em>, <em>estimated_sources</em><big>)</big><a class="headerlink" href="#mir_eval.separation.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the input data to a metric are valid, and throws helpful
errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>reference_sources <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt>
<dd><p class="first last">matrix containing true sources</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_sources <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt>
<dd><p class="first last">matrix containing estimated sources</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.bss_eval_sources">
<tt class="descclassname">mir_eval.separation.</tt><tt class="descname">bss_eval_sources</tt><big>(</big><em>reference_sources</em>, <em>estimated_sources</em><big>)</big><a class="headerlink" href="#mir_eval.separation.bss_eval_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>MATLAB translation of BSS_EVAL Toolbox</p>
<p>Ordering and measurement of the separation quality for estimated source
signals in terms of filtered true source, interference and artifacts.</p>
<p>The decomposition allows a time-invariant filter distortion of length
512, as described in Section III.B of <a class="footnote-reference" href="#vincent2006performance" id="id50">[37]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">sdr</span><span class="p">,</span> <span class="n">sir</span><span class="p">,</span> <span class="n">sar</span><span class="p">,</span>
<span class="go">     perm) = mir_eval.separation.bss_eval_sources(reference_sources,</span>
<span class="go">                                                  estimated_sources)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_sources <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt>
<dd><p class="first last">matrix containing true sources</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_sources <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt>
<dd><p class="first last">matrix containing estimated sources</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>sdr <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc,)</span></dt>
<dd><p class="first last">vector of Signal to Distortion Ratios (SDR)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sir <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc,)</span></dt>
<dd><p class="first last">vector of Source to Interference Ratios (SIR)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sar <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc,)</span></dt>
<dd><p class="first last">vector of Sources to Artifacts Ratios (SAR)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>perm <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc,)</span></dt>
<dd><p class="first last">vector containing the best ordering of estimated sources in
the mean SIR sense (estimated source number perm[j] corresponds to
true source number j)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided audio data is not in the correct format.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">References:</th><td class="field-body"><table class="first last docutils footnote" frame="void" id="vincent2006performance" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id50">[37]</a></td><td><p class="first last">Emmanuel Vincent, Rémi Gribonval, and
Cedric Fevotte, &#8220;Performance measurement in blind audio source
separation,&#8221; IEEE Trans.  on Audio, Speech and Language Processing,
14(4):1462-1469, 2006.</p>
</td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.separation.evaluate">
<tt class="descclassname">mir_eval.separation.</tt><tt class="descname">evaluate</tt><big>(</big><em>reference_sources</em>, <em>estimated_sources</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mir_eval.separation.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all metrics for the given reference and estimated annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># reference_sources[n] should be an ndarray of samples of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># n&#39;th reference source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># estimated_sources[n] should be the same for the n&#39;th estimated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">separation</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">reference_sources</span><span class="p">,</span>
<span class="go">                                          estimated_sources)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>reference_sources <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt>
<dd><p class="first last">matrix containing true sources</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>estimated_sources <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(nsrc, nsampl)</span></dt>
<dd><p class="first last">matrix containing estimated sources</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs</dt>
<dd><p class="first last">Additional keyword arguments which will be passed to the
appropriate metric or preprocessing functions.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>scores <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of scores, where the key is the metric name (str) and
the value is the (float) score achieved.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-mir_eval.util">
<span id="mir-eval-util"></span><h3><a class="reference internal" href="#module-mir_eval.util" title="mir_eval.util"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.util</span></tt></a><a class="headerlink" href="#module-mir_eval.util" title="Permalink to this headline">¶</a></h3>
<p>This submodule collects useful functionality required across the task
submodules, such as preprocessing, validation, and common computations.</p>
<dl class="function">
<dt id="mir_eval.util.index_labels">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">index_labels</tt><big>(</big><em>labels</em>, <em>case_sensitive=False</em><big>)</big><a class="headerlink" href="#mir_eval.util.index_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of string identifiers into numerical indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list of strings, shape=(n,)</span></dt>
<dd><p class="first last">A list of annotations, e.g., segment or chord labels from an
annotation file.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>case_sensitive <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set to <em>True</em> to enable case-sensitive label indexing</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>indices <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">Numerical representation of <em>labels</em></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>index_to_label <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><dl class="first last docutils">
<dt>Mapping to convert numerical indices back to labels.</dt>
<dd><p class="first last"><tt class="docutils literal"><span class="pre">labels[i]</span> <span class="pre">==</span> <span class="pre">index_to_label[indices[i]]</span></tt></p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.generate_labels">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">generate_labels</tt><big>(</big><em>items</em>, <em>prefix='__'</em><big>)</big><a class="headerlink" href="#mir_eval.util.generate_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array of items (e.g. events, intervals), create a synthetic label
for each event of the form &#8216;(label prefix)(item number)&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>items <span class="classifier-delimiter">:</span> <span class="classifier">list-like</span></dt>
<dd><p class="first last">A list or array of events or intervals</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>prefix <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">This prefix will be prepended to all synthetically generated labels</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">Synthetically generated labels</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_samples">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">intervals_to_samples</tt><big>(</big><em>intervals</em>, <em>labels</em>, <em>offset=0</em>, <em>sample_size=0.1</em>, <em>fill_value=None</em><big>)</big><a class="headerlink" href="#mir_eval.util.intervals_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of labeled time intervals to annotated samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, d)</span></dt>
<dd><p class="first last">An array of time intervals, as returned by
<a class="reference internal" href="#mir_eval.io.load_intervals" title="mir_eval.io.load_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt></a> or
<tt class="xref py py-func docutils literal"><span class="pre">mir_eval.io.load_labeled.intervals()</span></tt>.
The <em>i</em> th interval spans time <tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></tt> to
<tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">The annotation for each interval</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>offset <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Phase offset of the sampled time grid (in seconds)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sample_size <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">duration of each sample to be generated (in seconds)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">type(labels[0])</span></dt>
<dd><p class="first last">Object to use for the label with out-of-range time points.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>sample_times <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of sample times</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sample_labels <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">array of labels for each generated sample</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Intervals will be rounded down to the nearest multiple
of <em>frame_size</em>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.interpolate_intervals">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">interpolate_intervals</tt><big>(</big><em>intervals</em>, <em>labels</em>, <em>time_points</em>, <em>fill_value=None</em><big>)</big><a class="headerlink" href="#mir_eval.util.interpolate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign labels to a set of points in time given a set of intervals.</p>
<p>Note: Times outside of the known boundaries are mapped to None by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, d)</span></dt>
<dd><p class="first last">An array of time intervals, as returned by
:func:<tt class="docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt>.
The <em>i</em> th interval spans time <tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></tt> to
<tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list, shape=(n,)</span></dt>
<dd><p class="first last">The annotation for each interval</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>time_points <span class="classifier-delimiter">:</span> <span class="classifier">array_like, shape=(m,)</span></dt>
<dd><p class="first last">Points in time to assign labels.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fill_value <span class="classifier-delimiter">:</span> <span class="classifier">type(labels[0])</span></dt>
<dd><p class="first last">Object to use for the label with out-of-range time points.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>aligned_labels <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Labels corresponding to the given time points.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.f_measure">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">f_measure</tt><big>(</big><em>precision</em>, <em>recall</em>, <em>beta=1.0</em><big>)</big><a class="headerlink" href="#mir_eval.util.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the f-measure from precision and recall scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>precision <span class="classifier-delimiter">:</span> <span class="classifier">float in (0, 1]</span></dt>
<dd><p class="first last">Precision</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>recall <span class="classifier-delimiter">:</span> <span class="classifier">float in (0, 1]</span></dt>
<dd><p class="first last">Recall</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Weighting factor for f-measure</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>f_measure <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The weighted f-measure</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_boundaries">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">intervals_to_boundaries</tt><big>(</big><em>intervals</em><big>)</big><a class="headerlink" href="#mir_eval.util.intervals_to_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert interval times into boundaries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt>
<dd><p class="first last">Array of interval start and end-times</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>boundaries <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Interval boundary times, including the end of the final interval</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.boundaries_to_intervals">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">boundaries_to_intervals</tt><big>(</big><em>boundaries</em>, <em>labels=None</em><big>)</big><a class="headerlink" href="#mir_eval.util.boundaries_to_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array of event times into intervals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>boundaries <span class="classifier-delimiter">:</span> <span class="classifier">list-like</span></dt>
<dd><p class="first last">List-like of event times.  These are assumed to be unique
timestamps in ascending order.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">None or list of str</span></dt>
<dd><p class="first last">Optional list of strings describing each event</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n_intervals, 2)</span></dt>
<dd><p class="first last">Start and end time for each interval</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list of str or None</span></dt>
<dd><p class="first last">Labels for each event.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">If the input times are not unique and ascending</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.adjust_intervals">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">adjust_intervals</tt><big>(</big><em>intervals</em>, <em>labels=None</em>, <em>t_min=0.0</em>, <em>t_max=None</em>, <em>start_label='__T_MIN'</em>, <em>end_label='__T_MAX'</em><big>)</big><a class="headerlink" href="#mir_eval.util.adjust_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust a list of time intervals to span the range [t_min, t_max].</p>
<p>Any intervals lying completely outside the specified range will be removed.</p>
<p>Any intervals lying partially outside the specified range will be cropped.</p>
<p>If the specified range exceeds the span of the provided data in either
direction, additional intervals will be appended.  If an interval is
appended at the beginning, it will be given the label <em>start_label</em>; if an
interval is appended at the end, it will be given the label <em>end_label</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt>
<dd><p class="first last">Array of interval start and end-times</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list, len=n_events or None</span></dt>
<dd><p class="first last">List of labels</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>t_min <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">Minimum interval start time.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>t_max <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">Maximum interval end time.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>start_label <span class="classifier-delimiter">:</span> <span class="classifier">str or float or int</span></dt>
<dd><p class="first last">Label to give any intervals appended at the beginning</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>end_label <span class="classifier-delimiter">:</span> <span class="classifier">str or float or int</span></dt>
<dd><p class="first last">Label to give any intervals appended at the end</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>new_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Intervals spanning [t_min, t_max]</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>new_labels <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of labels for new_labels</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.adjust_events">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">adjust_events</tt><big>(</big><em>events</em>, <em>labels=None</em>, <em>t_min=0.0</em>, <em>t_max=None</em>, <em>label_prefix='__'</em><big>)</big><a class="headerlink" href="#mir_eval.util.adjust_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust the given list of event times to span the range [t_min, t_max].</p>
<p>Any event times outside of the specified range will be removed.</p>
<p>If the times do not span [t_min, t_max], additional events will be added
with the prefix label_prefix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>events <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of event times (seconds)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list or None</span></dt>
<dd><p class="first last">List of labels</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>t_min <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">Minimum valid event time.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>t_max <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">Maximum valid event time.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>label_prefix <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Prefix string to use for synthetic labels</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>new_times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Event times corrected to the given range.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intersect_files">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">intersect_files</tt><big>(</big><em>flist1</em>, <em>flist2</em><big>)</big><a class="headerlink" href="#mir_eval.util.intersect_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of two sets of filepaths, based on the file name
(after the final &#8216;/&#8217;) and ignoring the file extension.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">flist1</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/a/b/abc.lab&#39;</span><span class="p">,</span> <span class="s">&#39;/c/d/123.lab&#39;</span><span class="p">,</span> <span class="s">&#39;/e/f/xyz.lab&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flist2</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/g/h/xyz.npy&#39;</span><span class="p">,</span> <span class="s">&#39;/i/j/123.txt&#39;</span><span class="p">,</span> <span class="s">&#39;/k/l/456.lab&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sublist1</span><span class="p">,</span> <span class="n">sublist2</span> <span class="o">=</span> <span class="n">mir_eval</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">intersect_files</span><span class="p">(</span><span class="n">flist1</span><span class="p">,</span> <span class="n">flist2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sublist1</span>
<span class="go">[&#39;/e/f/xyz.lab&#39;, &#39;/c/d/123.lab&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sublist2</span>
<span class="go">[&#39;/g/h/xyz.npy&#39;, &#39;/i/j/123.txt&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>flist1 <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">first list of filepaths</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>flist2 <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">second list of filepaths</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>sublist1 <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">subset of filepaths with matching stems from <em>flist1</em></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>sublist2 <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">corresponding filepaths from <em>flist2</em></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.merge_labeled_intervals">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">merge_labeled_intervals</tt><big>(</big><em>x_intervals</em>, <em>x_labels</em>, <em>y_intervals</em>, <em>y_labels</em><big>)</big><a class="headerlink" href="#mir_eval.util.merge_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the time intervals of two sequences <em>x</em> and <em>y</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>x_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of interval times (seconds)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>x_labels <span class="classifier-delimiter">:</span> <span class="classifier">list or None</span></dt>
<dd><p class="first last">List of labels</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>y_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of interval times (seconds)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>y_labels <span class="classifier-delimiter">:</span> <span class="classifier">list or None</span></dt>
<dd><p class="first last">List of labels</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>new_intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">New interval times of the merged sequences.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>new_x_labels <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">New labels for the sequence <em>x</em></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>new_y_labels <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">New labels for the sequence <em>y</em></p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>ValueError</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The intervals of x and y must be aligned, or previously adjusted
via <a class="reference internal" href="#mir_eval.util.adjust_intervals" title="mir_eval.util.adjust_intervals"><tt class="xref py py-func docutils literal"><span class="pre">mir_eval.util.adjust_intervals()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.match_events">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">match_events</tt><big>(</big><em>ref</em>, <em>est</em>, <em>window</em><big>)</big><a class="headerlink" href="#mir_eval.util.match_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a maximum matching between reference and estimated event times,
subject to a window constraint.</p>
<p>Given two list of event times <em>ref</em> and <em>est</em>, we seek the largest set of
correspondences <tt class="docutils literal"><span class="pre">(ref[i],</span> <span class="pre">est[j])</span></tt> such that <tt class="docutils literal"><span class="pre">|ref[i]</span> <span class="pre">-</span> <span class="pre">est[j]|</span> <span class="pre">&lt;=</span>
<span class="pre">window</span></tt>, and each <tt class="docutils literal"><span class="pre">ref[i]</span></tt> and <tt class="docutils literal"><span class="pre">est[j]</span></tt> is matched at most once.</p>
<p>This is useful for computing precision/recall metrics in beat tracking,
onset detection, and segmentation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>ref <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,)</span></dt>
<dd><p class="first last">Array of reference event times</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>est <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(m,)</span></dt>
<dd><p class="first last">Array of estimated event times</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>window <span class="classifier-delimiter">:</span> <span class="classifier">float &gt; 0</span></dt>
<dd><p class="first last">Size of the window.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>matching <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd><p class="first last">A list of matched reference and event numbers.
<tt class="docutils literal"><span class="pre">matching[i]</span> <span class="pre">==</span> <span class="pre">(i,</span> <span class="pre">j)</span></tt> where <tt class="docutils literal"><span class="pre">ref[i]</span></tt> matches <tt class="docutils literal"><span class="pre">est[j]</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.validate_intervals">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">validate_intervals</tt><big>(</big><em>intervals</em><big>)</big><a class="headerlink" href="#mir_eval.util.validate_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that an (n, 2) interval ndarray is well-formed, and raises errors
if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">Array of interval start/end locations.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.validate_events">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">validate_events</tt><big>(</big><em>events</em>, <em>max_time=30000.0</em><big>)</big><a class="headerlink" href="#mir_eval.util.validate_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that a 1-d event location ndarray is well-formed, and raises
errors if not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>events <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,)</span></dt>
<dd><p class="first last">Array of event times</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>max_time <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">If an event is found above this time, the user will be warned.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.filter_kwargs">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">filter_kwargs</tt><big>(</big><em>function</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mir_eval.util.filter_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a function and args and keyword args to pass to it, call the function
but using only the keyword arguments which it accepts.  This is equivalent
to redefining the function with an additional **kwargs to accept slop
keyword args.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>function <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Function to call.  Can take in any number of args or kwargs</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.util.intervals_to_durations">
<tt class="descclassname">mir_eval.util.</tt><tt class="descname">intervals_to_durations</tt><big>(</big><em>intervals</em><big>)</big><a class="headerlink" href="#mir_eval.util.intervals_to_durations" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an array of n intervals to their n durations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n, 2)</span></dt>
<dd><p class="first last">An array of time intervals, as returned by
:func:<tt class="docutils literal"><span class="pre">mir_eval.io.load_intervals()</span></tt>.
The <em>i</em> th interval spans time <tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">0]</span></tt> to
<tt class="docutils literal"><span class="pre">intervals[i,</span> <span class="pre">1]</span></tt>.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>durations <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n,)</span></dt>
<dd><p class="first last">Array of the duration of each interval.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mir_eval.io">
<span id="mir-eval-io"></span><h3><a class="reference internal" href="#module-mir_eval.io" title="mir_eval.io"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.io</span></tt></a><a class="headerlink" href="#module-mir_eval.io" title="Permalink to this headline">¶</a></h3>
<p>Functions for loading in annotations from files in different formats.</p>
<dl class="function">
<dt id="mir_eval.io.load_delimited">
<tt class="descclassname">mir_eval.io.</tt><tt class="descname">load_delimited</tt><big>(</big><em>filename</em>, <em>converters</em>, <em>delimiter='\\s+'</em><big>)</big><a class="headerlink" href="#mir_eval.io.load_delimited" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function for loading in data from an annotation file where columns
are delimited.  The number of columns is inferred from the length of
the provided converters list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Usage:</th><td class="field-body"><div class="first highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Load in a one-column list of event times (floats)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">load_delimited</span><span class="p">(</span><span class="s">&#39;events.txt&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Load in a list of labeled events, separated by commas</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">load_delimited</span><span class="p">(</span><span class="s">&#39;labeled_events.csv&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="s">&#39;,&#39;</span><span class="p">)</span>
</pre></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to the annotation file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>converters <span class="classifier-delimiter">:</span> <span class="classifier">list of functions</span></dt>
<dd><p class="first last">Each entry in column n of the file will be cast by the function
converters[n].</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Separator regular expression.
By default, lines will be split by any amount of whitespace (&#8216;s+&#8217;)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul>
<li><dl class="first docutils">
<dt>columns <span class="classifier-delimiter">:</span> <span class="classifier">tuple of lists</span></dt>
<dd><p class="first last">Each list in this tuple corresponds to values in one of the columns
in the file.</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>ValueError</dt>
<dd><p class="first last">Thrown when the provided file is not in the specified format</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_events">
<tt class="descclassname">mir_eval.io.</tt><tt class="descname">load_events</tt><big>(</big><em>filename</em>, <em>delimiter='\\s+'</em><big>)</big><a class="headerlink" href="#mir_eval.io.load_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Import time-stamp events from an annotation file.  The file should
consist of a single column of numeric values corresponding to the event
times. This is primarily useful for processing events which lack duration,
such as beats or onsets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to the annotation file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Separator regular expression.
By default, lines will be split by any amount of whitespace (&#8216;s+&#8217;)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>event_times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">array of event times (float)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_labeled_events">
<tt class="descclassname">mir_eval.io.</tt><tt class="descname">load_labeled_events</tt><big>(</big><em>filename</em>, <em>delimiter='\\s+'</em><big>)</big><a class="headerlink" href="#mir_eval.io.load_labeled_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Import labeled time-stamp events from an annotation file.  The file should
consist of two columns; the first having numeric values corresponding to
the event times and the second having string labels for each event.  This
is primarily useful for processing labeled events which lack duration, such
as beats with metric beat number or onsets with an instrument label.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to the annotation file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Separator regular expression.
By default, lines will be split by any amount of whitespace (&#8216;s+&#8217;)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>event_times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">array of event times (float)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">list of labels</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_intervals">
<tt class="descclassname">mir_eval.io.</tt><tt class="descname">load_intervals</tt><big>(</big><em>filename</em>, <em>delimiter='\\s+'</em><big>)</big><a class="headerlink" href="#mir_eval.io.load_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import intervals from an annotation file.  The file should consist of two
columns of numeric values corresponding to start and end time of each
interval.  This is primarily useful for processing events which span a
duration, such as segmentation, chords, or instrument activation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to the annotation file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Separator regular expression.
By default, lines will be split by any amount of whitespace (&#8216;s+&#8217;)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt>
<dd><p class="first last">array of event start and end times</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_labeled_intervals">
<tt class="descclassname">mir_eval.io.</tt><tt class="descname">load_labeled_intervals</tt><big>(</big><em>filename</em>, <em>delimiter='\\s+'</em><big>)</big><a class="headerlink" href="#mir_eval.io.load_labeled_intervals" title="Permalink to this definition">¶</a></dt>
<dd><p>Import labeled intervals from an annotation file.  The file should consist
of three columns: Two consisting of numeric values corresponding to start
and end time of each interval and a third corresponding to the label of
each interval.  This is primarily useful for processing events which span a
duration, such as segmentation, chords, or instrument activation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to the annotation file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Separator regular expression.
By default, lines will be split by any amount of whitespace (&#8216;s+&#8217;)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(n_events, 2)</span></dt>
<dd><p class="first last">array of event start and end time</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">list of labels</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_time_series">
<tt class="descclassname">mir_eval.io.</tt><tt class="descname">load_time_series</tt><big>(</big><em>filename</em>, <em>delimiter='\\s+'</em><big>)</big><a class="headerlink" href="#mir_eval.io.load_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Import a time series from an annotation file.  The file should consist of
two columns of numeric values corresponding to the time and value of each
sample of the time series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to the annotation file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>delimiter <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Separator regular expression.
By default, lines will be split by any amount of whitespace (&#8216;s+&#8217;)</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">array of timestamps (float)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">array of corresponding numeric values (float)</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_patterns">
<tt class="descclassname">mir_eval.io.</tt><tt class="descname">load_patterns</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#mir_eval.io.load_patterns" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the patters contained in the filename and puts them into a list
of patterns, each pattern being a list of occurrence, and each
occurrence being a list of (onset, midi) pairs.</p>
<dl class="docutils">
<dt>The input file must be formatted as described in MIREX 2013:</dt>
<dd><a class="reference external" href="http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_%26_Sections">http://www.music-ir.org/mirex/wiki/2013:Discovery_of_Repeated_Themes_%26_Sections</a></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Params:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The input file path containing the patterns of a given
given piece using the MIREX 2013 format.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>pattern_list <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first">The list of patterns, containing all their occurrences,
using the following format:</p>
<div class="last highlight-python"><div class="highlight"><pre>pattern_list = [pattern1, ..., patternN]
pattern = [occurrence1, ..., occurrenceM]
occurrence = [onset_midi1, ..., onset_midiO]
onset_midi = (onset_time, midi_number)

E.g.:
P = [[[(77.0, 67.0), (77.5, 77.0), ... ]]]
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.io.load_wav">
<tt class="descclassname">mir_eval.io.</tt><tt class="descname">load_wav</tt><big>(</big><em>path</em>, <em>mono=True</em><big>)</big><a class="headerlink" href="#mir_eval.io.load_wav" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a .wav file as a numpy array using scipy.io.wavfile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>path <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path to a .wav file</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>mono <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If the provided .wav has more than one channel, it will be
converted to mono if mono=True.  Defaults to True.</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>audio_data <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Array of audio samples, normalized to the range [-1., 1.]</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Sampling rate of the audio data</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-mir_eval.sonify">
<span id="mir-eval-sonify"></span><h3><a class="reference internal" href="#module-mir_eval.sonify" title="mir_eval.sonify"><tt class="xref py py-mod docutils literal"><span class="pre">mir_eval.sonify</span></tt></a><a class="headerlink" href="#module-mir_eval.sonify" title="Permalink to this headline">¶</a></h3>
<p>Methods which sonify annotations for &#8220;evaluation by ear&#8221;.
All functions return a raw signal at the specified sampling rate.</p>
<dl class="function">
<dt id="mir_eval.sonify.clicks">
<tt class="descclassname">mir_eval.sonify.</tt><tt class="descname">clicks</tt><big>(</big><em>times</em>, <em>fs</em>, <em>click=None</em>, <em>length=None</em><big>)</big><a class="headerlink" href="#mir_eval.sonify.clicks" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a signal with the signal &#8216;click&#8217; placed at each specified time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">times to place clicks, in seconds</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">desired sampling rate of the output signal</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>click <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">click signal, defaults to a 1 kHz blip</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">desired number of samples in the output signal,
defaults to times.max()*fs + click.shape[0] + 1</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>click_signal <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Synthesized click signal</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.time_frequency">
<tt class="descclassname">mir_eval.sonify.</tt><tt class="descname">time_frequency</tt><big>(</big><em>gram</em>, <em>frequencies</em>, <em>times</em>, <em>fs</em>, <em>function=&lt;ufunc 'sin'&gt;</em>, <em>length=None</em><big>)</big><a class="headerlink" href="#mir_eval.sonify.time_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse synthesis of a time-frequency representation of a signal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Inputs:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>gram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">gram[n, m] is the magnitude of frequencies[n]
from times[n] to times[n + 1]</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>frequencies <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">array of size gram.shape[0] denoting the frequency of
each row of gram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">array of size gram.shape[1] denoting the start time of each
column of gram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">desired sampling rate of the output signal</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>function <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">function to use to synthesize notes, should be 2pi-periodic</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>length <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">desired number of samples in the output signal,
defaults to times[-1]*fs</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Outputs:</th><td class="field-body"><ul class="first last">
<li><dl class="first docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">synthetized version of the piano roll</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.chroma">
<tt class="descclassname">mir_eval.sonify.</tt><tt class="descname">chroma</tt><big>(</big><em>chromagram</em>, <em>times</em>, <em>fs</em><big>)</big><a class="headerlink" href="#mir_eval.sonify.chroma" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse synthesis of a chromagram (semitone matrix)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>chromagram <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(12, times.shape[0])</span></dt>
<dd><p class="first last">Chromagram matrix, where each row represents a semitone [C-&gt;Bb]
i.e., chromagram[3, j] is the magnitude of D# from times[j] to
times[j + 1]</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">The start time of each column in the chromagram</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Sampling rate to synthesize audio data at</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Synthesized chromagram</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="mir_eval.sonify.chords">
<tt class="descclassname">mir_eval.sonify.</tt><tt class="descname">chords</tt><big>(</big><em>chord_labels</em>, <em>intervals</em>, <em>fs</em><big>)</big><a class="headerlink" href="#mir_eval.sonify.chords" title="Permalink to this definition">¶</a></dt>
<dd><p>Synthesizes chord labels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><dl class="first docutils">
<dt>chord_labels <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">List of chord label strings.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>intervals <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, shape=(len(chord_labels), 2)</span></dt>
<dd><p class="first last">Start and end times of each chord label</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>fs <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Sampling rate to synthesize at</p>
</dd>
</dl>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul>
<li><dl class="first docutils">
<dt>output <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray</span></dt>
<dd><p class="first last">Synthesized chord labels</p>
</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">mir_eval</span></tt> Documentation</a><ul>
<li><a class="reference internal" href="#quickstart-using-the-evaluators">Quickstart: Using the evaluators</a></li>
<li><a class="reference internal" href="#quickstart-using-mir-eval-in-python-code">Quickstart: Using <tt class="docutils literal"><span class="pre">mir_eval</span></tt> in Python code</a></li>
<li><a class="reference internal" href="#installing-mir-eval">Installing <tt class="docutils literal"><span class="pre">mir_eval</span></tt></a></li>
<li><a class="reference internal" href="#mir-eval"><tt class="docutils literal"><span class="pre">mir_eval</span></tt></a><ul>
<li><a class="reference internal" href="#module-mir_eval.beat"><tt class="docutils literal"><span class="pre">mir_eval.beat</span></tt></a><ul>
<li><a class="reference internal" href="#conventions">Conventions</a></li>
<li><a class="reference internal" href="#metrics">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.chord"><tt class="docutils literal"><span class="pre">mir_eval.chord</span></tt></a><ul>
<li><a class="reference internal" href="#id14">Conventions</a></li>
<li><a class="reference internal" href="#id16">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.melody"><tt class="docutils literal"><span class="pre">mir_eval.melody</span></tt></a><ul>
<li><a class="reference internal" href="#id17">Conventions</a></li>
<li><a class="reference internal" href="#id18">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.onset"><tt class="docutils literal"><span class="pre">mir_eval.onset</span></tt></a><ul>
<li><a class="reference internal" href="#id27">Conventions</a></li>
<li><a class="reference internal" href="#id28">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.pattern"><tt class="docutils literal"><span class="pre">mir_eval.pattern</span></tt></a><ul>
<li><a class="reference internal" href="#id31">Conventions</a></li>
<li><a class="reference internal" href="#id32">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.segment"><tt class="docutils literal"><span class="pre">mir_eval.segment</span></tt></a><ul>
<li><a class="reference internal" href="#id40">Conventions</a></li>
<li><a class="reference internal" href="#id41">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.separation"><tt class="docutils literal"><span class="pre">mir_eval.separation</span></tt></a><ul>
<li><a class="reference internal" href="#id48">Conventions</a></li>
<li><a class="reference internal" href="#id49">Metrics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-mir_eval.util"><tt class="docutils literal"><span class="pre">mir_eval.util</span></tt></a></li>
<li><a class="reference internal" href="#module-mir_eval.io"><tt class="docutils literal"><span class="pre">mir_eval.io</span></tt></a></li>
<li><a class="reference internal" href="#module-mir_eval.sonify"><tt class="docutils literal"><span class="pre">mir_eval.sonify</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">mir_eval 0.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Colin Raffel et al..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>